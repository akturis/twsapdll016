|******************************************************************************
|* twsapdll0106  B61U_a8_gloc
|* Approval Document Storage Utilities
|* esuvorov
|* 2018-03-20 [03:12]
|******************************************************************************
|* Script Type: Library
|******************************************************************************
|********************* extern  functions **************************************
|* twsap.dll0116.update.approval.queue(
|* twsap.dll0116.update.integration.queue(
|* twsap.dll0116.process.selection.financial(
|* twsap.dll0116.process.approval.document(
|* twsap.dll0116.process.integration.transactions(
|* twsap.dll0116.process.integration.selectdo(
|* twsap.dll0116.generate.integration.queue(
|* twsap.dll0116.reset.integration.queue(
|* twsap.dll0116.type.to.sap(
|* twsap.dll0116.idtc.to.sap(
|* twsap.dll0116.idtc.query(
|* twsap.dll0116.get.fcmp.by.lcmp(
|* twsap.dll0116.print.tech.report(
|* twsap.dll0116.close.tech.report()
|* read.parallel.pack.num(
|* twsap.dll0116.read.parallel.mode(
|* twsap.dll0116.read.parallel.message(
|* twsap.dll0116.create.parallel.message(
|* twsap.dll0116.read.total.rec.in.pack(
|*
|******************************************************************************
|*	Rev.No. 1  twB61Ca8tvsd  21 Mar 18 esuvorov
|* initial development
|*	Rev.No. 2  twB61Ca8tvsz  08 ›???›??°›??? 18 ashvets
|* SH-20180508-1:Multu-company
|*	Rev.No. 3  twB61Ca8tvsz  10 ›???›??°›??? 18 ashvets
|* SH-20180510-1: multi-company
|*	Rev.No. 4  twB61Ca8tvsz  10 May 18 asuvoro
|* Group by business object position
|*	Rev.No. 5  twB61Ca8tvsz  10 ›???›??°›??? 18 ashvets
|* SH-20180510-1
|*	Rev.No. 6  twB61Ca8tvsz  11 ›???›??°›??? 18 ashvets
|* SH-20180511-1: multi-company
|*	Rev.No. 7  twB61Ca8tvsz  15 ›???›??°›??? 18 ashvetsf
|* SH-20180515-1:fixed error invoicing
|*	Rev.No. 8  twB61Ca8tvsz  16 May 18 easuvoro
|* Fixed logistics data for approval of purchase order returns
|*	Rev.No. 9  twB61Ca8tvsz  16 May 18 easuvoro
|* Integration transactions processing improvements
|*	Rev.No. 10  twB61Ca8tvsz  17 May 18 easuvoro
|* Added ranges for logistics order/transaction type
|*	Rev.No. 11  twB61Ca8tvsz  18 May 18 easuvoro
|* Bugfix koor/kost range selection
|*	Rev.No. 12  twB61Ca8tvsz  18 May 18 easuvoro
|* Fixed integration document query for koor/kost ranges
|*	Rev.No. 13  twB61Ca8tvsz  18 May 18 easuvoro
|* Added integration reconciliation processing for purchase orders
|*	Rev.No. 14  twB61Ca8tvsz  18 ›???›??°›??? 18 ashvets
|* incorrect check exist records in twsap106 in process twsap1206m200
|*	Rev.No. 15  twB61Ca8tvsz  18 ›???›??°›??? 18 ashvets
|* new field crus and logn
|*	Rev.No. 16  twB61Ca8tvsz  21 May 18 easuvoro
|* Fixed purchase order reconciliation data selection
|*	Rev.No. 17  twB61Ca8tvsz  21 May 18 easuvoro
|* Fixed purchase order reconciliation data selection
|*	Rev.No. 18  twB61Ca8tvsz  21 ›???›??°›??? 18 ashvets
|* SH-20180521-1:fixed error quan oper.costs
|*	Rev.No. 19  twB61Ca8tvsz  21 May 18 easuvoro
|* Empty order number (aufnr) for purchase receipts
|*	Rev.No. 20  twB61Ca8tvsz  22 May 18 easuvoro
|* Fixed koor/kost ranges in integration queue procedures
|*	Rev.No. 21  twB61Ca8tvsz  23 ›???›??°›??? 18 ashvets
|* COMMIT.100 and fixed error show curr. count in session
|*	Rev.No. 22  twB61Ca8tvsz  23 May 18 easuvoro
|* Additional check if integration document is applicable for the koor/kost
|* combination
|*	Rev.No. 23  twB61Ca8tvsz  29 ›???›??°›??? 18 ashvets
|* Fixed error generate GUID for operation costs
|*	Rev.No. 24  twB61Ca8tvsz  01 ›???›??I›??? 18 ashvets
|* update check batch status
|*	Rev.No. 25  twB61Ca8tvsz  05 ›???›??I›??? 18 ashvets
|* rem duplicate documents
|*	Rev.No. 26  twB61Ca8tvsz  07 ›???›??I›??? 18 ashvets
|* countity in invoicing
|*	Rev.No. 27  twB61Ca8tvsz  13 ›???›??I›??? 18 ashvets
|* New type
|*	Rev.No. 28  twB61Ca8tvsz  18 ›???›??I›??? 18 ashvets
|* sales invoicing twsap1206m400
|*	Rev.No. 29  twB61Ca8tvsz  18 ›???›??I›??? 18 ashvets
|* sales invoicing twsap1206m400
|*	Rev.No. 30  twB61Ca8tvsz  25 Jun 18 easuvoro
|* Breakdown of aggregate ledger account for sales invoices
|*	Rev.No. 31  twB61Ca8tvsz  26 Jun 18 easuvoro
|* Fixes for sales invoice processing
|*	Rev.No. 32  twB61Ca8tvsz  27 Jun 18 easuvoro
|* Multiple fixes for integration and sales invoicing
|*	Rev.No. 33  twB61Ca8tvsz  27 Jun 18 easuvoro
|* Fixed sales invoice details data
|*	Rev.No. 34  twB61Ca8tvsz  28 ›???›??I›??? 18 ashvets
|* New select Export intergation transaction by queue with tmp table twsap110
|*	Rev.No. 35  twB61Ca8tvsz  28 ›???›??I›??? 18 ashvets
|* tmp table twsap110 v.2
|*	Rev.No. 36  twB61Ca8tvsz  28 Jun 18 easuvoro
|* Fixed sales invoices processing: ctyp, cinv, itpi, cvat and posd
|*	Rev.No. 37  twB61Ca8tvsz  29 ›???›??I›??? 18 ashvets
|* temp table with package guid by 1000 records
|*	Rev.No. 38  twB61Ca8tvsz  02 ›???›??I›??» 18 ashvets
|* update incorrect records in deviations
|*	Rev.No. 39  twB61Ca8tvsz  02 ›???›??I›??» 18 ashvets
|* Fixed error in sales invoicing
|*	Rev.No. 40  twB61Ca8tvsz  03 ›???›??I›??» 18 ashvets
|* Fixed error fill twsap106.pcwar
|*	Rev.No. 41  twB61Ca8tvsz  04 ›???›??I›??» 18 ashvets
|* fitler idtc in guid list
|*	Rev.No. 42  twB61Ca8tvsz  05 ›???›??I›??» 18 ashvets
|* optimization select create queue and process.queue
|*	Rev.No. 43  twB61Ca8tvsz  09 ›???›??I›??» 18 ashvets
|* New case operation integration  TZ v47
|*	Rev.No. 44  twB61Ca8tvsz  09 ›???›??I›??» 18 ashvets
|* Incorrect type INC DEC corr.invoices
|*	Rev.No. 45  twB61Ca8tvsz  11 Jul 18 easuvoro
|* Sales invoice export fixes and sales storno case implementation
|*	Rev.No. 46  twB61Ca8tvsz  12 ›???›??I›??» 18 ashvets
|* technical report
|*	Rev.No. 47  twB61Ca8tvsz  13 ›???›??I›??» 18 ashvets
|* WH_Transfer_Low
|*	Rev.No. 48  twB61Ca8tvsz  13 ›???›??I›??» 18 ashvets
|* whinr110.itid to tech report
|*	Rev.No. 49  twB61Ca8tvsz  16 ›???›??I›??» 18 ashvets
|* Update dll
|* 1. clear bpid if not control account
|* 2. WH_Transfer_Low check type item
|*	Rev.No. 50  twB61Ca8tvsz  17 Jul 18 easuvoro
|* Sales invoices updates (sign of tax amounts and storno proc_id)
|*	Rev.No. 51  twB61Ca8tvsz  18 ›???›??I›??» 18 ashvets
|* fixed error split rbid to several guid
|*	Rev.No. 52  twB61Ca8tvsz  18 ›???›??I›??» 18 ashvets
|* add order type tckoor.cycle.count
|*	Rev.No. 53  twB61Ca8tvsz  19 ›???›??I›??» 18 ashvets
|* update function check.warehouse
|*	Rev.No. 54  twB61Ca8tvsz  20 ›???›??I›??» 18 ashvets
|* Update check WH_Transaction_Low
|*	Rev.No. 55  twB61Ca8tvsz  23 ›???›??I›??» 18 ashvets
|* Add new transactions SER_MAT_Issue, SER_MAT_Return
|*	Rev.No. 56  twB61Ca8tvsz  24 ›???›??I›??» 18 ashvets
|* Update check warehause
|*	Rev.No. 57  twB61Ca8tvsz  26 ›???›??I›??» 18 ashvets
|* WH_Transfer_Deviation
|*	Rev.No. 58  twB61Ca8tvsz  26 Jul 18 easuvoro
|* TVSZILS-13. Additional fields for storno sales and warehouse transfer related
|* sales invoices
|*	Rev.No. 59  twB61Ca8tvsz  27 Jul 18 ashvets
|* WH_Transfer
|*	Rev.No. 60  twB61Ca8tvsz  30 Jul 18 ashvets
|* Update Transfer transaction integration
|*	Rev.No. 61  twB61Ca8tvsz  30 Jul 18 easuvoro
|* TVSZILS-13. Enabled billing request template codes for internal transfer
|* sales
|*	Rev.No. 62  twB61Ca8tvsz  30 Jul 18 ashvets
|* Update WH_Transfer operations
|*	Rev.No. 63  twB61Ca8tvsz  30 Jul 18 easuvoro
|* TVSZILS-13. Fixed integration accounts selection for transfer invoicing
|*	Rev.No. 64  twB61Ca8tvsz  31 Jul 18 ashvets
|* No all wh.transfer have reconciliation
|*	Rev.No. 65  twB61Ca8tvsz  31 Jul 18 ashvets
|* Fixed error freeze in create transaction mapping
|*	Rev.No. 66  twB61Ca8tvsz  31 Jul 18 ashvets
|* add fill twsap109.date
|*	Rev.No. 67  twB61Ca8tvsz  01 Aug 18 easuvoro
|* Update integration reference identifier for sales invoices.
|*	Rev.No. 68  twB61Ca8tvsz  01 ›???›???›??? 18 vdudnik
|* Add filter tfgld495
|*	Rev.No. 69  twB61Ca8tvsz  01 Aug 18 easuvoro
|* Fixed integration document id for sales invoicing
|*	Rev.No. 70  twB61Ca8tvsz  01 Aug 18 ashvets
|* add message in function create.guid.list
|*	Rev.No. 71  twB61Ca8tvsz  01 Aug 18 easuvoro
|* Fixed original document references for specific sales invoice cases
|*	Rev.No. 72  twB61Ca8tvsz  01 Aug 18 easuvoro
|* Additional data for correction and adjustment sales invoices
|*	Rev.No. 73  twB61Ca8tvsz  01 ›???›???›??? 18 adubrovs
|* change order type for sal_internal_issue
|*	Rev.No. 74  twB61Ca8tvsz  02 Aug 18 ashvets
|* write skip.rbid to tech.report
|*	Rev.No. 75  twB61Ca8tvsz  02 Aug 18 ashvets
|* add type tckost.stc.correction to select
|*	Rev.No. 76  twB61Ca8tvsz  02 Aug 18 ashvets
|* cur.pack fixed mess
|*	Rev.No. 77  twB61Ca8tvsz  02 Aug 18 easuvoro
|* Fixer correction type indicator for correction and adjustment sales invoices
|*	Rev.No. 78  twB61Ca8tvsz  02 Aug 18 ashvets
|* fixed correction type koor_kost
|*	Rev.No. 79  twB61Ca8tvsz  02 Aug 18 ashvets
|* fixed correction order
|*	Rev.No. 80  twB61Ca8tvsz  02 Aug 18 ashvets
|* show information numb.pack
|*	Rev.No. 81  twB61Ca8tvsz  02 Aug 18 ashvets
|* add progress indicator
|*	Rev.No. 82  twB61Ca8tvsz  02 ›???›???›??? 18 ashvets
|* progress indicator
|*	Rev.No. 83  twB61Ca8tvsz  03 ›???›???›??? 18 ashvets
|* Cor_Result_Receipt and Cor_Result_Issue
|*	Rev.No. 84  twB61Ca8tvsz  03 ›???›???›??? 18 ashvets
|* update fill twsap106.cwar
|*	Rev.No. 85  twB61Ca8tvsz  03 ›???›???›??? 18 ashvets
|* fixed error read warehouse order seqn
|*	Rev.No. 86  twB61Ca8tvsz  03 ›???›???›??? 18 ashvets
|* update check btno
|*	Rev.No. 87  twB61Ca8tvsz  03 ›???›???›??? 18 ashvets
|* pack
|*	Rev.No. 88  twB61Ca8tvsz  03 ›???›???›??? 18 ashvets
|* fixed error in progress indicator
|*	Rev.No. 89  twB61Ca8tvsz  10 Aug 18 easuvoro
|* Added reverse update for "DEC" correction type, fixed _or and _st field sets
|* defaulting for document
|*	Rev.No. 90  twB61Ca8tvsz  13 ›???›???›??? 18 ashvets
|* copy functions to twsapdll0106 target list
|*	Rev.No. 91  twB61Ca8tvsz  14 ›???›???›??? 18 ashvets
|* Use one sql.id
|*	Rev.No. 92  twB61Ca8tvsz  15 ›???›???›??? 18 ashvets
|* fixed dubl used sql.id error
|*	Rev.No. 93  twB61Ca8tvsz  15 Aug 18 easuvoro
|* Updated quatity unit for approval documents
|*	Rev.No. 94  twB61Ca8tvsz  15 ›???›???›??? 18 ashvets
|* update reconciliation
|*	Rev.No. 95  twB61Ca8tvsz  15 Aug 18 easuvoro
|* Added rage of financial peruiods for financial routine
|*	Rev.No. 96  twB61Ca8tvsz  15 ›???›???›??? 18 ashvets
|* add new fields tsys,upid
|*	Rev.No. 2  twB61Ca8tvsz  16 ›???›???›??? 18 ashvets
|* create new table twsap116
|*	Rev.No. 3  twB61Ca8tvsz  17 ›???›???›??? 18 ashvets
|* parallel bshell for session twsap1206m100
|*	Rev.No. 4  twB61Ca8tvsz  03 ›???›??µ›??? 18 adubrovs
|* change key of grpk, adding rpon
|*	Rev.No. 5  twB61Ca8tvsz  04 ›???›??µ›??? 18 ashvets
|* Write twsap109.unid from twsap116.unid
|*	Rev.No. 6  twB61Ca8tvsz  05 ›???›??µ›??? 18 ashvets
|* Not write to buffer WH_transfer from 201 company to 202
|*	Rev.No. 7  twB61Ca8tvsz  05 ›???›??µ›??? 18 ashvets
|* Add twsap109._index2
|*	Rev.No. 8  twB61Ca8tvsz  06 ›???›??µ›??? 18 adubrovs
|* remove check of fi packets
|*	Rev.No. 9  twB61Ca8tvsz  06 ›???›??µ›??? 18 ashvets
|* Update queue for skiped transactions
|*	Rev.No. 10  twB61Ca8tvsz  20 ›???›??µ›??? 18 ashvets
|* add fill new fields dim4, iprd, iord and update fill field pcwar
|*	Rev.No. 11  twB61Ca8tvsz  20 ›???›??µ›??? 18 ashvets
|* update fill twsap116.iprt
|*	Rev.No. 12  twB61Ca8tvsz  05 ›??z›???›??A 18 adubrovs
|* adubrovskikh
|*	Rev.No. 13  twB61Ca8tvsz  05 ›??z›???›??A 18 ashvets
|* add check parameters twsap000
|*	Rev.No. 14  twB61Ca8tvsz  09 ›??z›???›??A 18 ashvets
|* Fixed error sql.query in function process.reconciliation
|*	Rev.No. 15  twB61Ca8tvsz  15 ›??z›???›??A 18 ashvets
|* parallel run oper costs
|*	Rev.No. 16  twB61Ca8tvsz  16 ›??z›???›??A 18 ashvets
|* Read paraller parameters from 201 company
|*	Rev.No. 17  twB61Ca8tvsz  16 ›??z›???›??A 18 adubrovs
|* Changed WO_Manual_Issue for 207 208
|*	Rev.No. 18  twB61Ca8tvsz  17 ›??z›???›??A 18 ashvets
|* Add new BO in operation costs
|*	Rev.No. 19  twB61Ca8tvsz  19 ›??z›???›??A 18 ashvets
|* Commit transaction only full document line created
|*	Rev.No. 20  twB61Ca8tvsz  23 ›??z›???›??A 18 adubrovs
|* 1) filling fiield AUFNR
|* 2) adding PUR_SUB*
|*	Rev.No. 21  twB61Ca8tvsz  23 ›??z›???›??A 18 adubrovs
|* changing subcontract idtc
|*	Rev.No. 22  twB61Ca8tvsz  31 ›??z›???›??A 18 adubrovs
|* add some code
|*	Rev.No. 23  twB61Ca8tvsz  07 ›???›???›??I 18 adubrovs
|* adding some fix
|*	Rev.No. 24  twB61Ca8tvsz  08 ›???›???›??I 18 ashvets
|* Add new case ZERO_PRICE operations
|*	Rev.No. 25  twB61Ca8tvsz  08 ›???›???›??I 18 ashvets
|* fill field twsap116.iord all time
|*	Rev.No. 26  twB61Ca8tvsz  08 ›???›???›??I 18 ashvets
|* fill leac ZERO_PRICE from integration settings
|*	Rev.No. 27  twB61Ca8tvsz  16 ›???›???›??I 18 adubrovs
|* fix field iprt
|*	Rev.No. 28  twB61Ca8tvsz  24 ›???›???›??I 18 ashvets
|* not use table integration
|*	Rev.No. 29  twB61Ca8tvsz  25 ›???›???›??I 18 ashvets
|* full twsap110.date
|*	Rev.No. 30  twB61Ca8tvsz  25 ›???›???›??I 18 ashvets
|* rem table twsap010
|*	Rev.No. 31  twB61Ca8tvsz  25 ›???›???›??I 18 ashvets
|* rem twsap010
|*	Rev.No. 32  twB61Ca8tvsz  30 ›???›???›??I 18 ashvets
|* SH-IPLC003-1:not create correspondec from wh_transfer_low
|*	Rev.No. 33  twB61Ca8tvsz  03 ›??”›??µ›??? 18 ashvets
|* SH-IPLINT008-1:fixed error if input ttyp/docn
|*	Rev.No. 34  twB61Ca8tvsz  03 ›??”›??µ›??? 18 ashvets
|* SH-IPLINT008-1:not wrote wh_transfer_low transactions
|*	Rev.No. 35  twB61Ca8tvsz  03 ›??”›??µ›??? 18 ashvets
|* SH-IPLCINT008-1: summ count only new operations in the queue
|*	Rev.No. 36  twB61Ca8tvsz  03 ›??”›??µ›??? 18 ashvets
|* SH-IPLCINT0708-1:summ only new operations in the queue
|*	Rev.No. 37  twB61Ca8tvsz  05 ›??”›??µ›??? 18 ashvets
|* SH-IPLCINT0009-1: fill twsap116.posd for ZERO.PRICE
|*	Rev.No. 38  twB61Ca8tvsz  07 ›??”›??µ›??? 18 ashvets
|* SH-IPLCINT0010-1: add new type warehause transfer
|*	Rev.No. 10  twB61Ra8tvsd  11 ›ј€”›ј€µ›ј€є 18 ashvets
|* SH-IPLCINT0011-1:Fill source warehause transaction number receipt and
|* shipment
|*	Rev.No. 11  twB61Ra8tvsd  11 ›ј€”›ј€µ›ј€є 18 ashvets
|* SH-IPLCINT0011-1:fixed error generate queue, writed error zero price records
|*	Rev.No. 12  twB61Ra8tvsd  12 ›ј€”›ј€µ›ј€є 18 ashvets
|* SH-IPLCINT0012-1:update queue for transaction skip_transaction
|*	Rev.No. 13  twB61Ra8tvsd  19 ›ј€”›ј€µ›ј€є 18 ashvets
|* SH-IPLCINT0014-1: update check process PUR_SUB_Receipt
|*	Rev.No. 14  twB61Ra8tvsd  20 ›ј€”›ј€µ›ј€є 18 ashvets
|* SH-IPLCINT0014-1: update check field idtc
|*	Rev.No. 15  twB61Ra8tvsd  24 ›ј€”›ј€µ›ј€є 18 ashvets
|* SH-IPLCINT0014-2:update type PUR_SUB_Receipt
|******************************************************************************
#ident "@(#)twsapdll0106  twB61Ca8tvsz  tvsz-hybrid01.tvsz.ru  Rev.No. 96  15 ›???›???›??? 18  ashvets"
#ident "@(#)twsapdll0116  twB61Ca8tvsz  tvsz-hybrid01.tvsz.ru  Rev.No. 39  10 ›??”›??µ›??? 18  ashvets"
#ident "@(#)twsapdll0116  twB61Ra8tvsd  tvsz-hybrid01.tvsz.ru  Rev.No. 15  21 ›ј€”›ј€µ›ј€є 18  ashvets"

	table	ttfgld106	|* Finalized Transactions
	table	ttfgld482	|* Integration Transactions
	table	ttwsap116	|* Approval Document Storage
	table	ttwsap109	|* Document Queue
	table	ttwsap108
	table	ttwsap110	|*
	table	twhinr110

	domain	tcguid		dll0106.unid
	domain	tcdate		dll0106.uplt

	domain	tcidty		g.int.idtc
	domain	tcbona		g.int.rbon
	domain	tcboid		g.int.rbid
	domain	tcsopo		g.int.rpon
	domain	tcdate		g.int.posd
	domain	tccuni		g.int.cuni
	domain	tfgld.dimx	g.int.cfod
	domain	tcorno		g.int.orno
	domain	tcitem		g.int.item
	domain	tccwar		g.int.cwar
	domain	tcqiv1		g.int.iqan
	domain	tcmcs.str10	g.int.bwtar
	domain	tcorno		g.int.itid
	domain	tcpono		g.int.itse
	domain	tcmcs.str32	g.int.itpi
	domain	tcncmp		g.int.lcmp

	domain	tcborf		g.int.obre
	domain	tcdate		g.int.crdt
	domain	tfgld.amnt	g.int.amnt
	domain	tfgld.amnt	g.int.amth
	domain	tcpono		g.int.pono
	domain	tcqiv1		g.inr.qstk
	domain	tckoor		g.inr.koor
	domain	tckost		g.inr.kost
	domain	whinh.shpm	g.inr.rcno					|#SH-IPLCINT0011-1.sn
	domain	tcpono		g.inr.rcln
	domain	whinh.shpm	g.inr.shpm					|#SH-IPLCINT0011-1.en


	domain	tcmcs.long	g.int.use.main.orno
	domain	tcorno		g.int.main.orno
	domain	tcpono		g.int.main.pono

	domain	tfgld.leac	g.agr.leac(1) based
		long		g.agr.leac.len

	|* ia?aiaiiue aey aaiiuo ii NO ec tfacp100/200
	domain	tfacp.isup 	g.inv.sfno
	domain	tfgld.date	g.inv.sfdt
	domain	tfacp.inv	g.inv.appr
	domain	tfyru.invf.l	g.inv.invf
	domain	tfgld.docn	g.inv.oinv
	domain	tfgld.amnt	g.inv.amti
	domain	tcpono		g.inv.adjn
	domain	tfgld.date	g.inv.rcpd


	|* ia?aiaiiua aey aaiiuo noi?ie?oaiie NO
		long		document.is.storno
	domain	tfgld.year	g.fyer_st
	domain	tfgld.prod	g.fprd_st
	domain	tfgld.ttyp	g.otyp_st
	domain	tfgld.docn	g.odoc_st
	domain	tfacp.isup 	g.sfno_st
	domain	tfgld.date	g.sfdt_st
	domain	tfgld.date	g.posd_st

	|* aaiiua i?eaeiaeuiiai NO aey ei??aeoe?iai?iiai
	domain	tfgld.ttyp	g.otyp_or
	domain	tfgld.docn	g.odoc_or
	domain	tfgld.year	g.fyer_or
	domain	tfgld.prod	g.fprd_or

	domain	tcmcs.str3	g.cort

	domain	tcmcs.long	g.guid.selected
	domain	tcguid		g.guid.list

	extern	long	dll.count.skip.btno
	extern	long	dll.count.skip.dupl
	extern	long	dll.count.guids

	|* var from session twsap1206m100
	extern	domain	tcyesno		tech.report
	extern			long		tech.report.id

					string		g.process.name(100)
	extern			long		g.cur.pack
	extern			long		g.max.pack.guid
					long		prog.ind
	|				long		g.new.sql.query


	|* from session twsap1206m100
	extern	domain	tcpono		g.count.in.pack
	extern	domain	tcdate		start.time
	extern	domain	tcdate		finish.time
	
			domain	tcmcs.st20m	g.upid
   			domain	tcmcs.str10	g.target
   			
	extern	domain	tcyesno	dll0116.use.hint   	

#define USE_HINT (dll0116.use.hint = tcyesno.yes)
			
|***********************  parallel bshell variable *************************
#include <bic_parallel>	  	

   	extern	domain	tcmcs.long	twsap.dll0116.parallel.run
	extern	domain	tcmcs.s256	twsap.dll0116.parallel.serv.mess

|		String		dll0106.data(1,1) based
|		long		dll0106.data.size
	domain 	tcbool		g.process.type

|* ooieoey n iae?inaie n?aaiaiey noii e eiee?anoa, n ieaaa?uae oi?eie
#include <bic_dam>
#include	"itcmcs0012"
#include	"itcfin0002"

|* Eiiiaiey aey ni?aai?ieeia
#define	TC.COMPANY 	201

#define IS.PROCESS.INVOICING	g.process.type = 1
#define IS.PROCESS.INTEGRATION	g.process.type = 2

#define	PURCH.INVOICING		"twsap1206m000"
#define SALES.INVOICING		"twsap1206m400"

#define ADD.FILTER.L(FLD,DMN,F.FROM,F.TO)
^	append.where.statement(get.inrange.sql.statement.long(
^			FLD, DMN, F.FROM, F.TO)) &" "

#define ADD.FILTER.STR(FLD,DMN,F.FROM,F.TO)
^	append.where.statement(get.inrange.sql.statement.string(
^			FLD, DMN, F.FROM, F.TO)) &" "

#define	DELIMITER	","
#define	RECONC.MASK	"reconc.mask"
#define	RECONC.MASK.TRF	"reconc.trf"
#define SELECT.GUID.LIST	"select.guid"

|* iae?inu aey neeaaneeo iia?aoee aac aaiiuo a tfgld482
#define ZERO_PRICE	"ZERO_P"
#define ZERO_PRICE_IDTC	"00000000"

#define COMMIT.100(NUM)
^	if NUM\100 = 0 then
^		commit.transaction()
^	endif

#define COMMIT.1000(NUM)
^	if NUM\1000 = 0 then
^		commit.transaction()
^	endif


#define PUR.RECEIPT
^			(g.inr.koor = tckoor.act.pur and g.inr.kost = tckost.receipt)

#define SUB.ISSUE
^			(g.inr.koor = tckoor.act.sls and g.inr.kost = tckost.issue and g.int.idtc <> "15060052")
#define SUB.RECEIPT
^			(g.inr.koor = tckoor.act.sfc and g.inr.kost = tckost.receipt and g.int.idtc <> "15061074")

#define	WH.TRANSFER
^			(g.inr.koor = tckoor.act.trf or
^			 g.inr.koor = tckoor.act.trf.man or
^			 g.inr.koor = tckoor.enterprise.plan)

#define TRF.RECEIPT
^			((g.inr.koor = tckoor.act.trf or
^			 g.inr.koor = tckoor.act.trf.man or
^			 g.inr.koor = tckoor.enterprise.plan) and
^			 g.inr.kost = tckost.receipt and
^			 |* WH_Transfer
^			 g.int.idtc = "10061074")

#define TRF.ISSUE.LOW
^			((g.inr.koor = tckoor.act.trf or
^			 g.inr.koor = tckoor.act.trf.man or
^			 g.inr.koor = tckoor.enterprise.plan) and
^			 g.inr.kost = tckost.issue and
^			 |* WH_Transfer_Low
^			 g.int.idtc = "10062052")

#define WRITE.OFF
^			(g.inr.koor = tckoor.act.sfc.man or
^		 	 g.inr.koor = tckoor.act.dpt.wrk.man or
^		 	 g.inr.koor = tckoor.act.asc.man)

#pragma used dll "owhinhdll0000"
|***************************** global variables *******************************

	|* ia?aiaiiua aey ?oaiey ia?aiao?ia NO e naycaiiuo aieoiaioia
	domain	tcmcs.str10	g.otyp.catg
	domain	tcmcs.str10	g.otyp.proc
	domain	tcmcs.str10	g.otyp.prct

	domain	tcmcs.str10	g.ctyp.catg
	domain	tcmcs.str10	g.ctyp.proc
	domain	tcmcs.str10	g.ctyp.prct

function extern twsap.dll0116.update.approval.queue(
					domain	tfgld.ttyp	i.atyp,
					domain	tfgld.docn	i.adoc,
					domain	tfgld.lino	i.alin
					|domain	tfgld.ttyp	i.ctyp,
					|domain	tfgld.docn	i.cinv,
					|domain	tcyesno		i.cont
					)
{
	DLLUSAGE
		|* 	caienu aieoiaioa ec o?eaaa?a cae?uouo iia?aoee
		|*	tfgld106ue UserExit
	ENDDLLUSAGE

	static	domain	tfgld.ttyp	prev.ttyp
	static	domain	tfgld.docn	prev.docn
	static	domain	tfgld.lino	prev.lino

	|* ia ia?aaaouaaou ianeieuei ?ac iaio e oo?a no?ieo aieoiaioa
	if i.atyp = prev.ttyp and i.adoc = prev.docn and i.alin = prev.lino then
		return
	endif

	prev.ttyp = i.atyp
	prev.docn = i.adoc
	prev.lino = i.alin

	|* na?in ana cia?aiee iieae oaaeeou i?a?aae ia aaoieoiua (i?enoea)
	db.set.to.default(ttwsap109)
	|twsap109.lcmp = get.compnr()
	twsap109.fcmp = twsap.dll0116.get.fcmp.by.lcmp(twsap109.lcmp)
	twsap109.lcmp = twsap109.fcmp
	twsap109.ttyp = i.atyp
	twsap109.docn = i.adoc
	twsap109.lino = i.alin
	|twsap109.ctyp = i.ctyp
	|twsap109.cinv = i.cinv
	|twsap109.cont = i.cont
	twsap109.date = utc.num()

	|* caienu aieoiaioa a i?a?aau, n ia?aiao?ii "neeiiaaou aoaeeeaou"
	|* aac ioeaee, ?oiau iaauei ianeieuei ?ac iaiie e oi? ?a no?iee aieoiaioa
	db.insert(ttwsap109, db.retry, db.skip.dupl)
}

|function extern twsap.dll0116.update.integration.queue(		|#SH-IPLINT008-1.o
function extern long twsap.dll0116.update.integration.queue( |#SH-IPLINT008-1.n
					domain	tcncmp		i.fcmp,
					domain	tcguid		i.guid,
					domain	tcidty		i.idtc,
					domain	tcbona		i.rbon,
					domain	tcboid		i.rbid,
					domain	tcsopo		i.rpon,
					domain	tfgld.ttyp	i.ityp,
					domain	tfgld.docn	i.idoc,
					domain	tcdate		i.trdt)
{
	static	domain	tcguid		prev.guid

	|* ia ia?aaaouaaou iaei e oio ?a aoea
	if i.guid = prev.guid then
		|return												|#SH-IPLINT008-1.o		
		return(false)										|#SH-IPLINT008-1.n
	endif

	prev.guid = i.guid

	|* na?in ana cia?aiee iieae oaaeeou i?a?aae ia aaoieoiua (i?enoea)
	db.set.to.default(ttwsap109)
	twsap109.lcmp = get.compnr()
	twsap109.fcmp = i.fcmp
	twsap109.guid = i.guid
	twsap109.idtc = i.idtc
	twsap109.rbon = i.rbon
	twsap109.rbid = i.rbid
	twsap109.rpon = i.rpon
	twsap109.ttyp = i.ityp
	twsap109.docn = i.idoc
	twsap109.trdt = i.trdt
	twsap109.date = utc.num()

	|* caienu aieoiaioa a i?a?aau, n ia?aiao?ii "neeiiaaou aoaeeeaou"
	|* aac ioeaee, ?oiau iaei GUID iia?aoee i?enoonaiaae iaei ?ac
	|db.insert(ttwsap109, db.retry, db.skip.dupl)		|#SH-IPLINT008-1.o
	e = db.insert(ttwsap109, db.retry, db.return.dupl)	|#SH-IPLINT008-1.sn
	|* EDUPL = 100
	if e = EDUPL then 
		e = 0 
		return(false)
	endif												|#SH-IPLINT008-1.en
	
	dll.count.guids = dll.count.guids + 1
	
	return(true)										|#SH-IPLINT008-1.n
}

function extern twsap.dll0116.process.selection.financial(
				domain	tcmcs.str13	i.process.code,
					long 		i.mode,
				domain	tcncmp		i.fcmp,
				domain	tcncmp		i.lcmp,
				domain	tfgld.ttyp	i.typf,
				domain	tfgld.ttyp	i.typt,
				domain	tfgld.docn	i.docf,
				domain	tfgld.docn	i.doct,
				domain	tfgld.year	i.yerf,
				domain	tfgld.year	i.yert,
				domain	tfgld.prod	i.perf,
				domain	tfgld.prod	i.pert,
					boolean		i.rpexp,
				domain	tcyesno		i.prep,
				domain	tcyesno		i.simm,
				ref	long		io.recs)
{

	|* auai?ea ec oaaeeou aieoiaioia tfgld018 ii aeaiaciio ia oi?ia
	|* eioi?uo aua iao ?anoe?aiiii aooa?a twsap116
	domain	tfgld.ttyp	cur.ttyp
	domain	tfgld.docn	cur.docn
		long		tmp.comm
	domain	tcncmp	dummy.ocmp
	domain	tcbool	skip.doc

	tmp.comm = false
	on case i.mode
		case 2: |* caiieieou i?a?aau
		case 3: |* i?enoeou i?a?aau
			if i.simm <> tcyesno.yes then
				tmp.comm = true
			endif
	endcase

	|* aey ?aaiou n i?a?aau?, anee ia oanoiaue ?a?ei, ioe?uaaai o?aicaeoe?
	if tmp.comm then
		db.retry.point()
	endif

	select	tfgld018.ttyp:cur.ttyp,
		tfgld018.docn:cur.docn
	from	tfgld018, tfgld100
	where	tfgld018._index1 inrange {:i.typf} and {:i.typt}
	and	tfgld018.docn inrange :i.docf and :i.doct
	and	tfgld018.year inrange :i.yerf and :i.yert
	and	tfgld018.trun > 0
	and	tfgld100._index1 = {tfgld018.year, tfgld018.btno}
	and	tfgld100.fprd inrange :i.perf and :i.pert
	and tfgld018._compnr = :i.fcmp
	selectdo
		on case i.mode
		case 1:
			|* ia?aaioea aieoiaioia aac i?a?aae
			skip.doc = false
			|if not i.rpexp then
			|	select	twsap116.ocmp:dummy.ocmp
			|	from	tfgld106, twsap116
			|	where	tfgld106._index1 = {:cur.ttyp,:cur.docn}
			|	  and 	tfgld106._compnr = :i.fcmp
			|	  and	twsap116._index2 = {
			|			tfgld106.ocmp,tfgld106.fyer,tfgld106.fprd,
			|			tfgld106.otyp,tfgld106.odoc}
			|	as set with 1 rows
			|	selectdo
			|		skip.doc = true
			|	endselect
			|endif

			if i.process.code = SALES.INVOICING then
				if not twsap.dll0116.document.is.sales.invoice(
							cur.ttyp, cur.docn)
				then
					skip.doc = true
				endif
				if not skip.doc then
					update.aggregate.ledger.accounts(
							i.fcmp, i.lcmp,
							cur.ttyp, cur.docn)
				endif
			endif

			|* caione caiieiaiey ?anoe?aiiiai aooa?a aey ea?aiai aieoiaioa.
			if not skip.doc then
				twsap.dll0116.process.approval.document(
					i.process.code,
					cur.ttyp, cur.docn,
					i.prep, i.simm,
					io.recs)
			endif
			break
		case 2:
			|* caiieiaiea i?a?aae
			skip.doc = false
			select 	twsap109.fcmp:dummy.ocmp
			from	twsap109
			where	twsap109._index1 = {:i.fcmp,:i.lcmp,
						:cur.ttyp,:cur.docn,0,""}
			as set with 1 rows
			selectdo
				skip.doc = true
			endselect

			if i.process.code = SALES.INVOICING then
				if not twsap.dll0116.document.is.sales.invoice(
								cur.ttyp, cur.docn)
				then
					skip.doc = true
				endif
			endif

			|* anee aieoiaio o?a ano a i?a?aae, oi neeioai aai
			if not skip.doc then
				io.recs = io.recs + 1
				if i.simm <> tcyesno.yes then
					twsap.dll0116.update.approval.queue(
						cur.ttyp,
						cur.docn,
						0)
				endif
			endif
			break
		case 3:
			|* i?euaai i?a?aau
			select 	twsap109.fcmp:dummy.ocmp
			from	twsap109 for update
			where	twsap109._index1 = {:i.fcmp,:i.lcmp,
						:cur.ttyp,:cur.docn,0,""}
			  and 	twsap109.proc = tcyesno.yes
			selectdo
				if i.process.code = SALES.INVOICING then
					if not twsap.dll0116.document.is.sales.invoice(
									cur.ttyp, cur.docn)
					then
						continue
					endif
				endif
				io.recs = io.recs + 1
				twsap109.proc = tcyesno.no
				if i.simm <> tcyesno.yes then
					db.update(ttwsap109,db.retry)
					|* ea?aua 100 caienae aaeaai eiiieo
					if io.recs \ 100 = 0 then
						commit.transaction()
					endif
				endif
			endselect
			break
		endcase
	endselect

	|* anee ioe?uee o?aicaeoe?, oi io?ii aa caeiieoeou
	if tmp.comm then
		commit.transaction()
	endif
}

function extern twsap.dll0116.process.approval.document(
					domain	tcmcs.str13	i.process.code,
					domain	tfgld.ttyp	i.atyp,
					domain	tfgld.docn	i.adoc,
					domain	tcyesno		i.prep,
					domain	tcyesno		i.simm,
				ref	domain	tcmcs.long	io.recs)
{
	DLLUSAGE
		|* Ia?aaioea ea?aiai aieoiaioa ii oaeoo?e?iaaie?
	ENDDLLUSAGE

|	domain	tcmcs.str50	document.key
		boolean		need.reset.sales.invoice
		long		tmp.tot.count

	boolean	invoice.processed, do.insert, print.report
	long	approval.sql, invoice.sql, next.seqn

	|* i?enaieou oieeaeuiue iiia? caiena.
	|* ?aae SAP iiaieiaai aoea a aa?oiee ?aaeno?
	dll0106.unid = toupper$(uuid.generate$())
	dll0106.uplt = 0 |utc.num()

|	free.mem(dll0106.data)
|	dll0106.data.size = 0

	|* caienuaaai a aeiaaeuio? ia?aiaii?, ?oi yoi ia?aaioea oaeoo?e?iaaiey
	IS.PROCESS.INVOICING

	next.seqn = 0
	invoice.processed = false
	do.insert = i.simm = tcyesno.no
	print.report = i.prep = tcyesno.yes

	|* aioo?e ooieoee auiieiyaony i?enoea aeiaaeuiuo ia?aiaiiuo
	empty.global.variables()

|	document.key = ""
|	on.change.check(document.key)
	need.reset.sales.invoice = false

	|* oi?ie?iaaiea aeiaie?aneiai SQL-cai?ina aey aeaaiiai aieoiaioa
	approval.sql = sql.parse(get.tfgld106.sql(i.atyp, i.adoc))

	|* caione cai?ina
	e = sql.exec(approval.sql)
	|* ia?aaioea ?acoeuoaoia cai?ina ii aeaaiiio aieoiaioo
	while not sql.fetch(approval.sql)
|		document.key = tfgld106.otyp & str$(tfgld106.odoc)
|		if changed(document.key) then
|			empty.global.storno.origin.fields()
|			on.change.check(document.key)
|		endif

		  |* aaoea oaeoo?e?iaaiey caeoiie
		  if tfgld106.otyp = "UTV" then
			|* ?eoaai iano?ieee aey oeia aieoiaioa ec twsap010
|			if not read.type.setting(
|					tfgld106.otyp,g.otyp.catg,
|					g.otyp.proc,g.otyp.prct) or
|			   not read.type.setting(
|					tfgld106.ctyp,g.ctyp.catg,
|					g.ctyp.proc,g.ctyp.prct)
|			then
|				|* anee aa?oa aey yoiai oeia iao iano?iae, oi i?iioneaai
|				|* yoo caienu e aa?ai neaao?uo? no?ieo a auai?ea
|				continue
|			endif

		|* Eaoaai?ey = UTV
		|if trim$(g.otyp.catg) = "UTV" then
			if not invoice.processed then
				|* anee oaeouee aieoiaio yaeyaony noi?ii
				document.is.storno = read.document.is.storno()
				if document.is.storno then
					|* ?eoaai aaiiua aey noi?ie?oaiiai aieoiaioa
					read.storno.document.data()
				else
					|* anee oaeouee aieoiaio ei??aeoe?iaea
					if read.invoice.form() then
						|* ?eoaai aaiiua ei??aeoe?oaiiai NO
					endif
				endif

				|* caiiiieou ana iiey oaeouae no?iee
				db.store.record(ttfgld106)
				|* oi?ie?iaaiea aeiaie?aneiai SQL-cai?ina aey naycaiiiai aieoiaioa
				invoice.sql = sql.parse(get.tfgld106.sql(
					tfgld106.ctyp, tfgld106.cinv))
				|* caione cai?ina invoice.sql
				e = sql.exec(invoice.sql)
				|* ia?aaioea ?acoeuoaoia cai?ina ii naycaiiiai aieoiaioo
				while not sql.fetch(invoice.sql)
					|* caienu ii no?ieai iaeaaiiui ii naycaiiiio aieoiaioo
					|* a ?anoe?aiiue aooa? twsap116
					fill.storage.record.buffer(
						i.process.code,
						next.seqn, false,
						print.report,
						do.insert)
				endwhile
				|* cae?uoea cai?ina invoice.sql
				e = sql.break(invoice.sql) + sql.close(invoice.sql)

				|* ainnoaiiaeaiea caiiiiaiie ?aiaa caiene db.store.record(ttfgld106)
				db.restore.record(ttfgld106)
				invoice.processed = true
			endif
			|* caienu ii no?ieai iaeaaiiui aey aeaaiiai aieoiaioa
			|* a ?anoe?aiiue aooa? twsap116
			fill.storage.record.buffer(
				i.process.code,
				next.seqn, true,
				print.report,
				do.insert)
		|*
		|* aaoea oaeoo?e?iaaiey i?iaa?
		else
			if twsap.dll0116.document.is.sales.invoice(
							tfgld106.otyp, tfgld106.odoc)
			then
				read.global.sales.invoice.data()
				need.reset.sales.invoice = true

				if not ledger.account.is.aggregate(tfgld106.leac)
				then
					fill.storage.record.buffer(
						i.process.code,
						next.seqn, true,
						print.report,
						do.insert)
				else
|					fill.storage.record.buffer(
|						next.seqn, true,
|						false, false)
|					next.seqn = next.seqn - 1

					fill.storage.record.sales.buffer(
						next.seqn, true, true,
						print.report,
						do.insert)
				endif
			endif
		endif


		tmp.tot.count = io.recs + next.seqn
		|* a iiaaae naaina aiaaaeai auaia eiee?anoaa ia?aaioaiiuo caienae
		show.progress.indicator(0,
			sprintf$("comp=%d,rec=%d",get.compnr(),tmp.tot.count),
			tmp.tot.count)
	endwhile

	|* n?eoaai eiee?ianoai caienaiiuo a aooa? caienae.
	|* neaicieeii ii anai eiiiaieyi.
	io.recs = io.recs + next.seqn

	close.progress.indicator()

	if need.reset.sales.invoice then
		tfgld106.ocmp = 0
		tfgld106.otyp = ""
		tfgld106.odoc = 0
		read.global.sales.invoice.data()
	endif
}

function extern twsap.dll0116.process.integration.transactions(
					domain	tcmcs.str13	i.process.code,
					domain	tcmcs.st20m	i.upid,
   					domain	tcmcs.str10	i.target,
					domain	tcmcs.long	i.new.mode,
					domain	tcncmp		i.fcmp,
					domain	tcncmp		i.lcmp,
					domain	tfgld.ttyp	i.typf,
					domain	tfgld.ttyp	i.typt,
					domain	tfgld.docn	i.docf,
					domain	tfgld.docn	i.doct,
					domain	tcidty		i.idtf,
					domain	tcidty		i.idtt,
					domain	tcbona		i.rbnf,
					domain	tcbona		i.rbnt,
					domain	tcboid		i.rbdf,
					domain	tcboid		i.rbdt,
					domain	tcdate		i.trdf,
					domain	tcdate		i.trdt,
					domain	tccwar		i.cwrf,
					domain	tccwar		i.cwrt,
					domain	tckoor		i.koor.f,
					domain	tckoor		i.koor.t,
					domain	tckost		i.kost.f,
					domain	tckost		i.kost.t,
						boolean		i.queue,
						boolean		i.rpexp,
					domain	tcyesno		i.prep,
					domain	tcyesno		i.simm,
				ref		long		io.recs
						)
{

	DLLUSAGE
		|* i.process.code - eia caiouaiiiai i?ioanna
		|*  - 'twsap1206m100' - ia?aaioea aieoiaioi ioionea/iinooieaiey SFC
		|*  - 'twsap1206m200' - ia?aaioea iia?aoeiiiuo cao?ao ii SFC
		|*  - iiea ana, ia ia oaeo ?oi iaanaaaa.
	ENDDLLUSAGE


	domain	tcmcs.str50	prv.grpk, cur.grpk, skip.grpk

					long		transaction.num 
		domain		tcncmp		tmp.comp
		domain		tcmcs.s140	dummy.add.text	
		boolean		grpk.changed
		boolean		do.insert, print.report
		long		next.seqn, sql.id|, dummy.long
		String		sql.str(8192)|, where.table(8)
		
		long		pack.from
		long		pack.to

		domain	tcdate	date.posd
				long	dummy.long

				String	rep.line(100)

		domain	tcmcs.str20	tmp.mode
	
	tmp.comp = get.compnr()	
	g.process.name = "Processed"
	prog.ind = 0
	transaction.num	= 0
	g.upid = i.upid
	g.target = i.target	
	prv.grpk = ""
	grpk.changed = false

	|* caienuaaai a aeiaaeuio? ia?aiaii?, ?oi yoi ia?aaioea eioaa?aoee
	IS.PROCESS.INTEGRATION
	|g.new.sql.query = true
	next.seqn = 0
	do.insert = i.simm = tcyesno.no
	print.report = i.prep = tcyesno.yes

	empty.global.variables()

	skip.grpk = ""
	db.set.to.default(ttfgld106)

	|* new select: filter guid by koor,kost,itdc before main select
	g.cur.pack = 0
	g.max.pack.guid = 0
	
	if not twsap.dll0116.parallel.run then
		if i.queue and i.process.code = "twsap1206m100" and i.new.mode then
			g.guid.list = fill.guid.list(
					i.process.code,
					i.fcmp, i.lcmp, i.typf, i.typt,
					i.docf, i.doct, i.idtf, i.idtt,
					i.rbnf, i.rbnt, i.rbdf, i.rbdt,
					i.trdf, i.trdt,
					i.cwrf, i.cwrt,
					i.koor.f, i.koor.t,
					i.kost.f, i.kost.t,
					i.queue,
					print.report,
					do.insert,
					io.recs,			|* iiaoo i?eaaaeony iia?aoee n ioeaaie
					g.max.pack.guid)	|* noieiinou?
			if not isspace(g.guid.list) then
				g.guid.selected = true
			else
				close.progress.indicator()
				return
			endif
			if run.parallel.process(
						"process.tr",
						g.upid,
						g.target,
						i.fcmp,
						i.lcmp,
						i.simm,
						g.guid.list,
						1,
						g.max.pack.guid,
						i.koor.f,
						i.koor.t,
						i.kost.f,
						i.kost.t,
						io.recs) > 0 
			then 
				
				return
			endif
		endif
	endif

	if g.max.pack.guid = 0 then
		g.max.pack.guid = 1
	endif

	sql.id = 0
	pack.from = 1 
	pack.to = g.max.pack.guid
	
	if twsap.dll0116.parallel.run then
		|* ?acae?aai niiauaiea
		if not twsap.dll0116.read.parallel.message(
		  				twsap.dll0116.parallel.serv.mess,
		  				tmp.mode,
						g.upid,
						g.target,
						i.fcmp,
						i.lcmp,
						i.simm,
						g.guid.list,
						pack.from,
						pack.to,
						i.koor.f,
						i.koor.t,
						i.kost.f,
						i.kost.t,
						dummy.add.text)
		then 
			message("@incorrect serv.mess")
			return
		endif
		
		if tmp.comp <> i.lcmp then 
			e = switch.to.company(i.lcmp)
		endif
		
		if not isspace(g.guid.list) then
				g.guid.selected = true
		else
			return
		endif
		
		|* ia?aii?aaaeyai iaeioi?ua ia?aiaiiua aey ia?aeeaeuiiai caionea
		do.insert = (i.simm = tcyesno.no)
		io.recs = 0 
		dll.count.guids = 0
		
		|* ia?aaa?a ia?aiao?a dll0116.use.hint a ia?aeeaeuiue i?ioann
		if trim$(dummy.add.text) = "1" then 
			dll0116.use.hint = tcyesno.yes
		else
			dll0116.use.hint = tcyesno.no
		endif
		
		if do.insert then 
			par.server.retry.point()
		    db.retry.point()
		    if db.retry.hit() then
		        par.server.retry.hit()
		    endif
		endif
	endif
	
	|for g.cur.pack = 1 to g.max.pack.guid
	for g.cur.pack = pack.from to pack.to
		domain	tcmcs.str100	add.where.start

		add.where.start = sprintf$("tfgld482._index2 = {%d} ", i.lcmp)

		|if g.guid.selected and g.max.pack.guid > 1 then
		if g.guid.selected then
			add.where.start = add.where.start &
					sprintf$(" and twsap110.seqn = {:511} ")
		endif

		|if sql.id = 0 then
			sql.str = get.integration.sql(i.process.code,
					g.guid.list,
					i.fcmp, i.lcmp, i.typf, i.typt,
					i.docf, i.doct, i.idtf, i.idtt,
					i.rbnf, i.rbnt, i.rbdf, i.rbdt,
					i.trdf, i.trdt,
					i.koor.f, i.koor.t,
					i.kost.f, i.kost.t,
					i.queue,
					add.where.start)
					|sprintf$("tfgld482._index2 = {%d} ", i.lcmp))
			twsap.dll0116.print.tech.report(sql.str)
			sql.id = sql.parse(sql.str)

			g.inr.koor = i.koor.f
			g.inr.kost = i.kost.f
		|endif

		
		|if g.guid.selected and g.max.pack.guid > 1 then
		if g.guid.selected then
			|* ia?aaaai a cai?in aeooaeuiua ia?aiaiiua
			e = sql.where.bind(sql.id,510, g.guid.list)
			e = sql.where.bind(sql.id,511, g.cur.pack)
		endif
		bind.integration.variables(i.process.code, sql.id)

		|* caione cai?ina
		e = sql.exec(sql.id)

		|* oeee ii ia?aaioea ?acoeuoaoa
		|* oeia ?acaae selectdo
		while not sql.fetch(sql.id)
			|iai?ai kost ae? io?eaooaeuiuo neeaaneeo iia?aoee
|			if g.inr.qstk < 0 and g.inr.kost = tckost.stc.correction then
|				on case g.inr.kost
|					case tckost.receipt:
|						g.inr.kost = tckost.issue
|						break
|					case tckost.issue:
|						g.inr.kost = tckost.receipt
|						break
|				endcase
|			endif
			|* iu o?a iooeeuo?iaaee a iaeaoao ii neeaao
			if not g.guid.selected then 
				if not check.warehouse(
							g.int.cwar,g.int.orno,g.int.pono,
							g.inr.koor,g.inr.kost,
							i.cwrf,i.cwrt)
				then
						|* aa?ai neaao?uo? caienu
						continue
				endif
			endif

			|* check whether integration document is allowed for specific
			|* koor/kost combination as initial range may include
			|* unnecessary documents for specific cases
			if pos(twsap.dll0116.idtc.query(     			|#SH-XXXXXXXX-1.so
					false,	| aiaaaeou and aia?aea
					g.inr.koor, g.inr.koor,
					g.inr.kost, g.inr.kost,
					i.process.code,
					"t1"), g.int.idtc) <= 0
			then
				continue
			endif											|#SH-XXXXXXXX-1.eo

			|* ia?aaanoe aaoo ec UTC a DATE
			utc.to.local(g.int.posd,date.posd, dummy.long)

			if not preprocess.integration.selectdo(i.process.code,i.fcmp) then
				|* if TRF.ISSUE.LOW but transaction "100060052" then skip
				if do.insert then
					|* iiia?aai caiene eae ia?aaioaiiua n i?eciaeii skip...
					twsap116.ocmp = tfgld106.ocmp		|#SH-IPLCINT0012-1.sn
					|g.int.lcmp,
					twsap116.rbon = g.int.rbon 
					twsap116.rbid = g.int.rbid
					twsap116.rpon = g.int.rpon			
					update.queue("skip_transaction")	|#SH-IPLCINT0012-1.en
					|update.queue("skip transaction")	|#SH-IPLCINT0012-1.o	
				endif
				if tech.report = tcyesno.yes then
					if not transfer.order.mapping.for.rbid.exist(g.int.rbid) then
						rep.line = concat$("~",
											"skip rbid=",
											g.int.rbid)
						|* write skip.rbid to tech report
						twsap.dll0116.print.tech.report(rep.line)
					endif
				endif
				continue
			endif

			cur.grpk = 	concat$("/",
						g.int.itpi, g.int.rbon, g.int.rbid, g.int.rpon,
						date.posd, | = tfgld482.trdt
					   	tfgld106.otyp, tfgld106.odoc)

			if cur.grpk = skip.grpk then
				|dll.count.skip.btno = dll.count.skip.btno + 1
				continue
			endif

			if prv.grpk <> cur.grpk then
				on case i.process.code
				case "twsap1206m100":
					|* ii eiaaeno 2 iu iaoee 3 iaeaoa, aey aieuoae oi?iinoe
					|* aiaaaeee aaoo tfgld482.trdt
					select	tfgld482.btno from tfgld482
					where	tfgld482._index2 = {:tfgld106.ocmp,
							:g.int.rbon, :g.int.rbid, :g.int.rpon}
					and	tfgld482._compnr = :i.fcmp
					and tfgld482.trdt = :tfgld482.trdt
					and	(	tfgld482.btno = 0 or exists (
							select	tfgld100.trun from tfgld100
							where	tfgld100._index1 = {
									:tfgld106.fyer,
									tfgld482.btno}
							and	tfgld100.stat <> tfgld.bstt.term
							and	tfgld100._compnr = :i.fcmp))
					as set with 1 rows
					selectdo
					|*  i?iioneaai i?iaa?eo iaeaoia
					|*	skip.grpk = cur.grpk
					endselect
					if cur.grpk = skip.grpk then
						|dll.count.skip.btno = dll.count.skip.btno + 1
						continue
					endif
					break
				endcase

				grpk.changed = true
				prv.grpk = cur.grpk
				dll0106.unid = toupper$(uuid.generate$())
				dll.count.guids = dll.count.guids + 1
				dll0106.uplt = utc.num()
				|* n?eoaai eiee?anoai caienaiiuo a aooa? caienae.
				|* neaicieeii ii anai eiiiaieyi.
				io.recs = io.recs + next.seqn
				next.seqn = 0
				
				if do.insert then 
					|* caaa?oaai o?aicaeoe? oieuei anee aieuoa 1000 
					|* e iaiyaony aieoiaio
					if (io.recs - transaction.num) >= 1000 then 
						transaction.num = io.recs
						commit.transaction()
					endif
				endif
				
			endif

			if i.process.code = "twsap1206m200" then
				g.inr.qstk = g.int.iqan
			endif

			g.int.use.main.orno = false

			If not WH.TRANSFER or
			  trim$(g.int.itpi) = "WH_Transfer_Low" or	|#SH-IPLCINT008-1.n		|#SH-IPLCINT0011-1.o
			  trim$(g.int.itpi) = "PUR_Internal_Receipt" or
			  trim$(g.int.itpi) = "SAL_Internal_Issue"
			then
				twsap.dll0116.process.integration.selectdo(
					i.process.code,
					|inr.qstk,
					|tmp.lcmp,	|* eiaenoe?aneay eiiiaiey
					g.int.amnt,
					g.int.amth,
					print.report,
					do.insert,
					i.rpexp,
					next.seqn,
					io.recs)
			endif

			if	must.be.found.reconciliation()  and
				grpk.changed
			then
				|if TRF.RECEIPT or TRF.ISSUE.LOW then
				if WH.TRANSFER then
					g.int.use.main.orno = true
					g.int.main.orno    = g.int.orno
					g.int.main.pono    = g.int.pono
				endif

				process.reconciliation(
					i.process.code,
					i.fcmp, i.lcmp, i.typf, i.typt,
					i.docf, i.doct, i.idtf, i.idtt,
					i.rbnf, i.rbnt, i.rbdf, i.rbdt,
					i.trdf, i.trdt,
					i.koor.f, i.koor.t,
					i.kost.f, i.kost.t,
					|i.queue,
					false,	|* aey ioaaoiie ?anoe iaio?ai oeeuo? ii i?a?aae
					print.report,
					do.insert,
					i.rpexp,
					next.seqn,
					io.recs)
					|false)
			endif
			grpk.changed = false
		endwhile
		|* cai?in niae?aai iaei ?ac, caoai iaiyai oieuei iiia? iaeaoa
		e = sql.break(sql.id)
		|* oaaeyai noi?ie?iaaiiue cai?in
		e = sql.close(sql.id)
		|* n?eoaai eiee?ianoai caienaiiuo a aooa? caienae.
		|* neaicieeii ii anai eiiiaieyi.
		io.recs = io.recs + next.seqn
		next.seqn = 0
	endfor
	
	sql.id = 0

	if twsap.dll0116.parallel.run then 
		if do.insert then 
				commit.transaction()
		endif
		|* iinueaai niiauaiea eeeaioo n eiee?anoaii caienae
		par.server.send.message(
					concat$("~",true,dll.count.guids,io.recs))
	else
		if not isspace(g.guid.list) then
			show.progress.indicator(1,"Clear package list table ",io.recs)
			clear.guid.list(g.guid.list)
			g.cur.pack = 0
			g.max.pack.guid = 0
		endif
	endif
	close.progress.indicator()
	
}


function String fill.guid.list(
					domain	tcmcs.str13	i.process.code,
					domain	tcncmp		i.fcmp,
					domain	tcncmp		i.lcmp,
					domain	tfgld.ttyp	i.typf,
					domain	tfgld.ttyp	i.typt,
					domain	tfgld.docn	i.docf,
					domain	tfgld.docn	i.doct,
					domain	tcidty		i.idtf,
					domain	tcidty		i.idtt,
					domain	tcbona		i.rbnf,
					domain	tcbona		i.rbnt,
					domain	tcboid		i.rbdf,
					domain	tcboid		i.rbdt,
					domain	tcdate		i.trdf,
					domain	tcdate		i.trdt,
					domain	tccwar		i.cwrf,
					domain	tccwar		i.cwrt,
					domain	tckoor		i.koor.f,
					domain	tckoor		i.koor.t,
					domain	tckost		i.kost.f,
					domain	tckost		i.kost.t,
							boolean		i.queue,
							boolean		i.print.report,
							boolean		i.do.insert,
				ref			long		io.recs,
				ref	domain	tcmcs.long	o.max.pack.guid)
{
	String		sql.str(8192), where.table(8)
	String		test.sql.str(8192)
	|domain		tcboid	save.rbid
	long		sql.id
	long		tot.rec.count
	long		cur.pack.count
	long		cur.pack
	long 		check.rec.count

	domain	tcguid o.prid
	domain	tcmcs.long	tmp.seqn
	domain	tcdate	tmp.utc

|#define MAX.PACK.GUID	1000
|#define MAX.PACK.GUID	g.count.in.pack

	o.prid = ""
	tot.rec.count = 0
	cur.pack.count = 0
	cur.pack = 1
	check.rec.count = 0

	if g.count.in.pack = 0 then
		g.count.in.pack = 1000
	endif

	show.progress.indicator(1,"Create package list",0)

	|* checkpoint value set to ""
	twsap110.rbid = ""
	on.change.check(twsap110.rbid)
	
	twsap109.rbid = "" 
	on.change.check(twsap109.rbid)

	sql.str = get.integration.sql(SELECT.GUID.LIST,
				"", |* guid list
				i.fcmp, i.lcmp, i.typf, i.typt,
				i.docf, i.doct, i.idtf, i.idtt,
				i.rbnf, i.rbnt, i.rbdf, i.rbdt,
				i.trdf, i.trdt,
				i.koor.f, i.koor.t,
				i.kost.f, i.kost.t,
				i.queue,
				"")

	twsap.dll0116.print.tech.report(sql.str)
	sql.id = sql.parse(sql.str)

	|* caione cai?ina
	e = sql.exec(sql.id)

	|* oeee ii ia?aaioea ?acoeuoaoa
	|* oeia ?acaae selectdo
	while not sql.fetch(sql.id)
		check.rec.count = check.rec.count + 1
		show.progress.indicator(1,
					sprintf$("create pack: Pack=%d,count.pack=%d, line=%s",
						cur.pack,cur.pack.count,
						concat$("/",
							check.rec.count,
							whinr110.cwar,whinr110.orno,whinr110.pono,
							whinr110.koor,whinr110.kost)),
							0)
		if not check.warehouse(
					whinr110.cwar,whinr110.orno,whinr110.pono,
					whinr110.koor,whinr110.kost,
					i.cwrf,i.cwrt)
		then
			|* aa?ai neaao?uo? caienu
			continue
		endif
		
		if isspace(o.prid) then
			o.prid = toupper$(uuid.generate$())
			tmp.utc = utc.num()
		endif
		
		
		|* Caienu a aooa? neeaaneie iia?aoee aey eioi?ie iao
		|* iia?aoee eioaa?aoee a tfgld482
		if twsap109.guid(1;6) =  ZERO_PRICE then 
			if changed(twsap109.rbid) then
				dll0106.unid = toupper$(uuid.generate$())
				|* aiaaaeyai eiee?anoai nicaaiiuo GUID
				dll.count.guids = dll.count.guids + 1
				tmp.seqn = 0
			endif
			|* aiaaaeyai a n?ao?ee aua?o?aiiuo caienae
			io.recs = io.recs + 1
			
			fill.buffer.zero.price(
					tmp.seqn,
					i.print.report,
					i.do.insert)
			|* caiiieiaai eiee?anoai oaeeo caienae, ?oiau iioii aiaaaeou a iauee 
			|* n?ao?ee
			|* aa?ai neaao?uo? caienu
			continue
		endif

		cur.pack.count = cur.pack.count + 1
		twsap110.prid = o.prid
		twsap110.guid = twsap109.guid
		twsap110.rbid = twsap109.rbid


		|if cur.pack.count > MAX.PACK.GUID then
		if cur.pack.count > g.count.in.pack then
			| changed() returns TRUE here, but also sets
			if changed(twsap110.rbid) then
				|show.progress.indicator(1,
				|	sprintf$("create pack: Pack=%d,count.pack=%d, line=",
				|	cur.pack,cur.pack.count))

				cur.pack = cur.pack + 1
				cur.pack.count = 1
			endif
		else
			|* checkpoint value set to curr value
			on.change.check(twsap110.rbid)
		endif

		twsap110.seqn = cur.pack

		tot.rec.count = tot.rec.count + 1
		
		twsap110.date = tmp.utc
		db.insert(ttwsap110,db.retry,db.skip.dupl)
		COMMIT.1000(cur.pack.count)
	endwhile

	commit.transaction()

	e = sql.break(sql.id) + sql.close(sql.id)

	o.max.pack.guid = cur.pack
	return(o.prid)
}

function clear.guid.list(
				domain	tcguid i.prid)
{
	long		tmp.rec.cunt

	tmp.rec.cunt = 0
	|db.retry.point()
	select 	*
	from	twsap110 for update
	where	twsap110._index1 = {:i.prid}
	selectdo
		tmp.rec.cunt = tmp.rec.cunt + 1
		db.delete(ttwsap110,db.retry)
		COMMIT.1000(tmp.rec.cunt)
	endselect

	commit.transaction()
}

function String get.integration.sql(
					domain	tcmcs.str13	i.process.code,
					domain	tcguid		i.guid.list,
					domain	tcncmp		i.fcmp,
					domain	tcncmp		i.lcmp,
					domain	tfgld.ttyp	i.typf,
					domain	tfgld.ttyp	i.typt,
					domain	tfgld.docn	i.docf,
					domain	tfgld.docn	i.doct,
					domain	tcidty		i.idtf,
					domain	tcidty		i.idtt,
					domain	tcbona		i.rbnf,
					domain	tcbona		i.rbnt,
					domain	tcboid		i.rbdf,
					domain	tcboid		i.rbdt,
					domain	tcdate		i.trdf,
					domain	tcdate		i.trdt,
					domain	tckoor		i.koor.f,
					domain	tckoor		i.koor.t,
					domain	tckost		i.kost.f,
					domain	tckost		i.kost.t,
						boolean		i.queue,
					domain	tcmcs.str100	i.where.start)
{
	String		sql.str(8192), where.table(8)
	String		test.sql.str(8192)

	|* niae?aai aeiaie?aneea SQL cai?in aey auai?a aaiiuo
	if i.process.code =  SELECT.GUID.LIST then
		sql.str =	"select	twsap109.rbid, twsap109.guid, " &
						  " whinr110.cwar, whinr110.orno, " &
						  " whinr110.pono, whinr110.koor, " &
						  " whinr110.kost, " & 
						  |* iiey io?iu aey no?ie ZERO_PRICE
						  " whinr110.item, " &
						  "	whinr110.cwar, whinr110.qstk, " & 
						  " whinr110.ocmp, whinr110.trdt "

	else
		sql.str =	"select	" &
		    "   tfgld482.fyer:tfgld106.fyer,"&
			"	tfgld482.fprd:tfgld106.fprd,"&
			|"	tfgld482.ratd:tfgld106.ratd,"&
			|"	tfgld482.rate:tfgld106.rate,"&
			|"	tfgld482.ratf:tfgld106.fact,"&
			|"	tfgld482.rtyp:tfgld106.rtyp,"&
			"	tfgld482.fcom:tfgld106.ocmp,"&
|			"	tfgld482.ttyp:tfgld106.otyp,"&
|			"	tfgld482.docn:tfgld106.odoc,"&
			"	tfgld482.crus:tfgld106.user,"&
			"	tfgld482.dbcr:tfgld106.dbcr,"&
			"	tfgld482.leac:tfgld106.leac,"&
			"	tfgld482.ccur:tfgld106.ccur,"&
			"	tfgld482.dim1:tfgld106.dim1,"&
			"	tfgld482.dim4:tfgld106.dim4,"&
			"	tfgld482.bpid:tfgld106.bpid,"&
			"  	tfgld482.trdt, " &
			"	tfgld482.idtc:1,"&
			"	tfgld482.rbon:2,"&
			"	tfgld482.rbid:3,"&
			"	tfgld482.rpon:4,"&
			"	tfgld482.trdt:5,"&
			"	tfgld482.cuni:6,"&
			"	tfgld482.crdt:7, "
	endif

	on case i.process.code
		case SELECT.GUID.LIST:
			if USE_HINT then 
				sql.str = sql.str &
					"from	twsap109, whinr110 "
			else
				sql.str = sql.str &
					"from	whinr110 "
			endif
			break
		case RECONC.MASK.TRF:
		case "twsap1206m100":
			sql.str = sql.str &
					"	sum(tfgld482.amnt):8,"&
					"	sum(tfgld482.amth(1)):9, "&
					"	sum(tfgld482.nuni):10, " &
					"   tfgld482.ocmp:11," &
					"	whinr110.orno:100,"&				|#SH-XXXXXXXX-1.so
					"	whinr110.pono:108,"&
					"	whinr110.item:101,"&
					"	whinr110.cwar:102,"&
					"	whinr110.qstk:103,"&
					"	whinr110.koor:106,"&
					"	whinr110.kost:107,"&				|#SH-XXXXXXXX-1.eo
					"	whinr110.rcno:110,"&			|#SH-IPLCINT0011-1.sn
					"   whinr110.rcln:111,"&
					"   whinr110.shpm:112 " 			|#SH-IPLCINT0011-1.en
					|"	whina124.itid:104,"&
					|"	whina124.itse:105 "
					|"	whinr110.itid:104,"&
					|"	whinr110.itse:105 "

			if USE_HINT then 
				sql.str = sql.str &
					|"from	tfgld482, whinr110, whina124 "
					"from	twsap110, tfgld482, whinr110 "	|#SH-XXXXXXXX-1.o
					|"from	twsap110, tfgld482 "  			|#SH-XXXXXXXX-1.n
			else
				sql.str = sql.str &
					|"from	tfgld482, whinr110, whina124 "
					"from	tfgld482, whinr110 "
			endif
			break
		case RECONC.MASK:
			sql.str = sql.str &
					"	tfgld482.obre:101, "&
					"	tfgld482.amnt:8,"&
					"	tfgld482.amth(1):9, "&
					"	tfgld482.nuni:10, " &
					"	tfgld482.dim3:tfgld106.dim3,"&
					"	tfgld482.rbid:100 "
			sql.str = sql.str & "from tfgld482 "
			break
		case "twsap1206m200":
			sql.str = sql.str &
					"	tfgld482.ttyp:tfgld106.otyp,"&
					"	tfgld482.docn:tfgld106.odoc,"&
					"	tfgld482.lino:tfgld106.olin,"&
					"	tfgld482.amnt:8,"&
					"	tfgld482.amth(1):9, "&
					"	tfgld482.nuni:10, " &
					"   tfgld482.ocmp:11, " &
					"	tfgld482.dim3:tfgld106.dim3,"&
|					"	tfgld482.bpid:tfgld106.bpid,"&
					"	tfgld482.rbid:100 "				|* orno
			sql.str = sql.str &
				"from	tfgld482,tfgld100 "
			break
	endcase

	|* aey oanoe?iaaiey n oeioaie e aac io?ii a ia?aea ooieoee ia?aaioee
	|* a aaaaaa?a eciaieou yoo ia?aiaiio?
	if not USE_HINT then 
		if i.queue then
			|if g.guid.selected then
			if not isspace(i.guid.list) then 
				|* yoi oieuei ?a?ei "twsap1206m100" ia?aianaii auoa
				sql.str = sql.str & ", twsap110 "
			else
				|* yoi oieuei ?a?ei SELECT.GUID.LIST ia?aianaii auoa
				sql.str = sql.str & ", twsap109 "
			endif
		endif
		|* yoi oieuei ?a?ei  RECONC.MASK.TRF ia?aianaii auoa
		if i.process.code = RECONC.MASK.TRF then
			sql.str = sql.str & ", twsap110 "
		endif
	endif


|	sql.str = sql.str &
|			sprintf$("where tfgld482._index2 = {%d} " &
|			   		" and tfgld482._compnr = %d ",
|			   		i.lcmp, i.fcmp)

	if i.process.code = SELECT.GUID.LIST then
		sql.str = sql.str & "where "&
|							|"whina124._index1 = {twsap109.guid} "
							"whinr110._index5 = {twsap109.rbid,twsap109.rpon} "
							|"and whinr110.trdt = twsap109.trdt"
	else
		sql.str = sql.str & "where "& strip$(i.where.start) &
				(isspace(i.where.start) ? "" : " and ")&
				sprintf$("tfgld482._compnr = %d ", i.fcmp)
	endif

	|sprintf$("where tfgld482._index2 = {%d} ", get.compnr())

	|* a caaeneiinoe io ia?aiao? "I?a?aau" eeai aiaaaeyai a SQL-ia?aie?aiea
	|* ii i?a?aae twsap109 + oeeuo?u, eeai oeeuo?u i?eiaiyai e
	|* oaaeeoa eioaa?aoee
	if i.queue then
		|sql.str = sql.str &
		|	sprintf$("tfgld482.guid in (select twsap109.guid "&
		|	             " from  twsap109 " &
		|	             " where twsap109.proc = tcyesno.no " &
		|	             " and   twsap109._index1 inrange {%s,%d,0} and {%s,%d,0} " &
		|	             " and   twsap109.guid <> '' ",
		|	             quoted.string(i.typf), i.docf,
		|	             quoted.string(i.typt), i.doct)

		|* ia?aie?eaaai ii oeiainiaie eiiiaiee
		if i.process.code <> SELECT.GUID.LIST then
			sql.str = sql.str &
				sprintf$(" and  tfgld482._index4 = {%d} ",i.fcmp)
		endif
		|* test_1 oanoe?iaaiea iioeiecaoee cai?ina ii i?a?aae, ii iieiui aeaiaciiai.

		|if not g.guid.selected then
		if isspace(i.guid.list) then
			|* anee iieiua aeaiaciiu, oi iie iai ia io?iu a auai?ea,
			|* ia?aiaiiay 	test.sql.str aoaao ionoay
			test.sql.str =
					(ADD.FILTER.STR("tfgld482.ttyp", "tfgld.ttyp",i.typf,i.typt) &
					ADD.FILTER.L("tfgld482.docn", "tfgld.docn", i.docf, i.doct))
			if isspace(test.sql.str) then
				sql.str = sql.str &
						sprintf$(
							" and twsap109._index1 = {%d,%d} " &
							" and twsap109.proc = tcyesno.no " &
							" and twsap109.guid <> '' ",
						            |* aiaaaeee ia?aie?aiea ii i?a?aae ia eiiiaiee
						            |* oeiainiao? e eiaenoe?aneo?
						            i.fcmp,i.lcmp)
				if i.process.code <> SELECT.GUID.LIST then
					sql.str = sql.str &
							" and tfgld482._index1 = {twsap109.guid} "
				endif
			else
				sql.str = sql.str &
					sprintf$(
						" and twsap109._index1 inrange {%1$d,%2$d,%3$s,%4$d,0,%7$s.guid} " &
					   	" and {%1$d,%2$d,%5$s,%6$d,0,%7$s.guid} " &
						" and twsap109.proc = tcyesno.no " &
						" and twsap109.guid <> '' ",
					            |* aiaaaeee ia?aie?aiea ii i?a?aae ia eiiiaiee
					            |* oeiainiao? e eiaenoe?aneo?
					            i.fcmp,i.lcmp,quoted.string(i.typf), i.docf,
					            			  quoted.string(i.typt), i.doct,
					            i.process.code = SELECT.GUID.LIST ? "twsap109":"tfgld482")
				|* i?eciae ?oi oeeuo?oai ii i?a?aae
			endif
			where.table = "twsap109"
		endif
	else
		|* Oaaeeoa ?anoa?aia, iiyoiio ia?aie?eaaou ii eiiiaiee ia iaai
		|* Eiaaenu caeii?eeenu !!!!!!!!!!!!!!!!!!!!!!!!!!!!o
		|sql.str = sql.str &
		|	sprintf$("tfgld482._index2 = {%d} ", get.compnr())

		if i.process.code <> RECONC.MASK and
		   i.process.code <> RECONC.MASK.TRF
		then
			|* eniieucoai oeeuo? ii eiaaeno
			sql.str = sql.str & sprintf$(" and  tfgld482._index4 "&
					"inrange {%d,%s,%d} and {%d,%s,%d} ",
					i.fcmp, quoted.string(i.typf), i.docf,
					i.fcmp, quoted.string(i.typt), i.doct)
		endif

		|* i?eciae ?oi oeeuo?oai ii eioaa?aoee
		where.table = "tfgld482"
	endif

	|* aiienuaaai oeeuo aey aua?aiiie oaaeeou twsap109/tfgld482

	if i.process.code <> RECONC.MASK and
	   i.process.code <> RECONC.MASK.TRF and
	   |not g.guid.selected
	   isspace(i.guid.list)
	then
		sql.str = sql.str &
			ADD.FILTER.STR(where.table&".idtc", "tcidty",   i.idtf, i.idtt) &
			ADD.FILTER.STR(where.table&".rbon", "tcbona",   i.rbnf, i.rbnt) &
			ADD.FILTER.STR(where.table&".rbid", "tcboid",   i.rbdf, i.rbdt) &
			ADD.FILTER.L(where.table&".trdt", "tcdate",     i.trdf, i.trdt)
	endif

	|if not i.queue then
	|	sql.str = sql.str &
	|		ADD.FILTER.STR(where.table&".ttyp", "tfgld.ttyp",i.typf,i.typt) &
	|		ADD.FILTER.L(where.table&".docn", "tfgld.docn", i.docf, i.doct)
	|endif
	|sql.str = sql.str & sprintf$(
	|	" and %s.rbon inrange %s and %s"&
	|	" and %s.rbid inrange %s and %s"&
	|	" and %s.idtc inrange %s and %s"&
	|	" and %s.docn inrange %d and %d"&
	|	" and %s.trdt inrange %s and %s ",
	|	where.table, quoted.string(i.rbnf), quoted.string(i.rbnt),
	|	where.table, quoted.string(i.rbdf), quoted.string(i.rbdt),
	|	where.table, quoted.string(i.idtf), quoted.string(i.idtt),
	|	where.table, i.docf, i.doct,
	|	where.table, i.trdf, i.trdt)

	|* a caaeneiinoe io caiouaiiiai i?ioanna, ia?aie?eaaai auai?eo ii
	|* oeiai eioaa?aoeiiiuo aieoiaioia
	|if not g.guid.selected then
	if i.process.code = SELECT.GUID.LIST or
	   i.process.code = RECONC.MASK
	   |or
	   |i.process.code = RECONC.MASK.TRF
	then
		sql.str = sql.str & twsap.dll0116.idtc.query(
				true,	| aiaaaeou and aia?aea
				i.koor.f, i.koor.t,
				i.kost.f, i.kost.t,
				i.process.code,
				where.table)
	endif
	if i.queue then
		|* anee auae?aai ii i?a?aae,
		|* oi aa?ai oieuei iaia?aaioaiiua ?aiaa no?iee
		|sql.str = sql.str &" and twsap109.proc = tcyesno.no) "
		|sql.str = sql.str &" ) "
	endif

	if i.process.code <> SELECT.GUID.LIST then
		sql.str = sql.str &" and	tfgld482.sint = tfgld.ints.posted "
	endif

	on case i.process.code
	case SELECT.GUID.LIST:
		sql.str = sql.str &
				|" and	whina124._index1 = {twsap109.guid} "&
				|" and	whina124.typt = tcemm.enty.warehouse "&
				|" and	whinr110._index5 = {"&
				|	"whina124.itid, whina124.itse,"&
				|	"whina124.itmt, whina124.codt}"&
				|" and winr110.itid = twsap109.rbid " &
				|" and winr110.trdt = twsap109.trdt " &
				" and whinr110.itid = twsap109.rbid " &
				get.koor.kost.statement("whinr110",
					i.koor.f, i.koor.t,
					i.kost.f, i.kost.t)
		break
	case RECONC.MASK.TRF:
	case "twsap1206m100":
		|if g.guid.selected then
		if not isspace(i.guid.list) then
			|sql.str = sql.str &
			|			sprintf$(
			|				" and twsap110._index1 = {'%s'} " &
			|				" and tfgld482._index1 = {twsap110.guid} ",
			|				i.guid.list)
			sql.str = sql.str &
						sprintf$(
							" and twsap110._index1 = {:510} " &
							" and tfgld482._index1 = {twsap110.guid} ")
		|endif
		else
			sql.str = sql.str & |sprintf$(
				|* eiaenoe?aneea eiiiaiee
				|" and whinr110._compnr = tfgld482.ocmp " &
				|" and whina124._compnr = tfgld482.ocmp " &
				||" and	whina124._index1 = {tfgld482.guid} "&
				||" and	whina124.typt = tcemm.enty.warehouse "&
				||" and	whinr110._index5 = {"&
				||	"whina124.itid, whina124.itse,"&
				||	"whina124.itmt, whina124.codt}"&
				|" and whinr110.itid = tfgld482.rbid " &
				|" and whinr110.itse = tfgld482.rpon " &

				|" and	whinr110.koor = %d "&
				|" and	whinr110.kost = %d "&
				get.koor.kost.statement("whinr110",
					i.koor.f, i.koor.t,
					i.kost.f, i.kost.t)
		endif
		sql.str = sql.str & |sprintf$(
				" and whinr110.itid = tfgld482.rbid " &	|#SH-XXXXXXXX-1.so
				" and whinr110.itse = tfgld482.rpon " &	|#SH-XXXXXXXX-1.eo
				"group by"&
				"	tfgld482.fyer, tfgld482.fprd, tfgld482.crdt,"&
				|"	tfgld482.ratd, tfgld482.rate, tfgld482.ratf,"&

|				"	tfgld482.rtyp, tfgld482.fcom, tfgld482.ttyp,"&
|				"	tfgld482.docn, tfgld482.crus, tfgld482.dbcr,"&
				|"	tfgld482.rtyp, " &
				"	tfgld482.fcom, " &
				"	tfgld482.crus, tfgld482.dbcr,"&

				"	tfgld482.leac, tfgld482.ccur, tfgld482.idtc,"&
				"	tfgld482.rbon, tfgld482.rbid, tfgld482.rpon,"&
				"	tfgld482.trdt, tfgld482.cuni, tfgld482.dim1,"&
				"	tfgld482.dim4,"&
				"	tfgld482.bpid, "&
				"	whinr110.orno, whinr110.pono, whinr110.item, "&		|#SH-XXXXXXXX-1.so
				"	whinr110.cwar, whinr110.qstk, whinr110.koor, "&
				"	whinr110.kost, "&									|#SH-XXXXXXXX-1.eo
				"	whinr110.rcno, "&			|#SH-IPLCINT0011-1.sn
				"   whinr110.rcln, "&
				"   whinr110.shpm, "&			|#SH-IPLCINT0011-1.en
				|"	whinr110.kost, whina124.itid, whina124.itse "
				
				|"	whinr110.itid, whinr110.itse "
				"	tfgld482.ocmp "
				|"order by tfgld482.rbon, tfgld482.rbid ",
|				etol(i.koor.f), etol(i.kost.f))
		break
	case "twsap1206m200":
		|* i?iaa?ea iaeaoa ia cae?uoea
		sql.str = sql.str &
			sprintf$(" and	tfgld100._compnr = %d "&
					"  and	tfgld100._index1 = {tfgld482.fyer,tfgld482.btno} " &
					"  and	tfgld100.stat = tfgld.bstt.term ",
					i.fcmp)
		break
	endcase

|	if i.process.code <> RECONC.MASK then
|		sql.str = sql.str &
|			"order by tfgld482.rbon, tfgld482.rbid,"&
|			"tfgld482.rpon"
||			"tfgld482.ttyp, tfgld482.docn"
|	endif

	|* Ni?oe?iaea auae?aaiuo caienae
	on case i.process.code
	case SELECT.GUID.LIST:
		sql.str = sql.str &
			|" group by twsap109.rbid, twsap109.guid, " &
			| 		 " whinr110.cwar, whinr110.orno, " &
			|		 " whinr110.pono, whinr110.koor, " &
			|		 " whinr110.kost " &
			" order by twsap109.rbid ,twsap109.guid "
		break
	case RECONC.MASK.TRF:
	case "twsap1206m100":
		sql.str = sql.str &
			"order by tfgld482.rbon, tfgld482.rbid,"&
			"tfgld482.rpon, tfgld482.trdt, tfgld482.idtc "
		
		if USE_HINT then
			sql.str = sql.str & 
					" hint ordered " & 
					" and use index 1 on twsap110 " & 
					" and use index 1 on tfgld482 "
		endif
		break
	case "twsap1206m200":
		sql.str = sql.str &
			"order by tfgld482.ttyp, tfgld482.docn," &
			" tfgld482.rbon, tfgld482.rbid,"&
			"tfgld482.rpon"
		break
	endcase

	return (sql.str)
}

function bind.integration.variables(	domain	tcsess		i.process.code,
						long		i.sql.id)
{
	e = sql.select.bind(i.sql.id,  1, g.int.idtc)
	e = sql.select.bind(i.sql.id,  2, g.int.rbon)
	e = sql.select.bind(i.sql.id,  3, g.int.rbid)
	e = sql.select.bind(i.sql.id,  4, g.int.rpon)
	e = sql.select.bind(i.sql.id,  5, g.int.posd)
	e = sql.select.bind(i.sql.id,  6, g.int.cuni)
	e = sql.select.bind(i.sql.id,  7, g.int.crdt)
	e = sql.select.bind(i.sql.id,  8, g.int.amnt)
	e = sql.select.bind(i.sql.id,  9, g.int.amth)
	e = sql.select.bind(i.sql.id, 10, g.int.iqan) |* nuni
	e = sql.select.bind(i.sql.id, 11, g.int.lcmp)
	e = sql.select.bind(i.sql.id,100, g.int.orno)  		|#SH-XXXXXXXX-1.o

	on case i.process.code
		case RECONC.MASK:
			e = sql.select.bind(i.sql.id, 101, g.int.obre)
			break
		case RECONC.MASK.TRF:
		case "twsap1206m100":
			e = sql.select.bind(i.sql.id, 101, g.int.item)  		|#SH-XXXXXXXX-1.so
			e = sql.select.bind(i.sql.id, 102, g.int.cwar)
			e = sql.select.bind(i.sql.id, 103, g.inr.qstk)
			|e = sql.select.bind(i.sql.id, 104, g.int.itid)
			|e = sql.select.bind(i.sql.id, 105, g.int.itse)
			e = sql.select.bind(i.sql.id, 106, g.inr.koor)
			e = sql.select.bind(i.sql.id, 107, g.inr.kost)	
			e = sql.select.bind(i.sql.id, 108, g.int.pono)			|#SH-XXXXXXXX-1.eo
			e = sql.select.bind(i.sql.id, 110, g.inr.rcno)		|#SH-IPLCINT0011-1.sn
			e = sql.select.bind(i.sql.id, 111, g.inr.rcln)	
			e = sql.select.bind(i.sql.id, 112, g.inr.shpm)		|#SH-IPLCINT0011-1.en
			break
	endcase
}

function long preprocess.integration.selectdo(
				domain	tcmcs.str13	i.process.code,
				domain	tcncmp		i.fcmp)
{
	|* if return(false) then skip this transaction

	domain	tcitem		pur.item
	domain	tccwar		pur.cwar
	domain	tcborf		pur.obre
	domain	tcmcs.str5	pur.pono, pur.sqnb
	domain	tccotp		tmp.otyp
	domain	tccwar	tmp.sfco
	domain	tccwar	tmp.stco
	domain  tctyps	tmp.sfty 
	domain	tctyps	tmp.stty
	domain	tccwoc	tmp.cwoc, tmp.wdep	
		boolean		pur.case
		long		dummy.long
		
	domain	tcyesno		tmp.subc					|#SH-IPLCINT0014-1.n

	pur.case = g.int.idtc(1; 5) = "10001"
	if pur.case and not isspace(g.int.obre) then
		e = string.scan(g.int.obre, "%s/%s/%s",
			pur.pono, pur.sqnb, pur.obre)

		pur.item = ""
		pur.cwar = ""
		select	tdpur401.item:pur.item,
			tdpur401.cwar:pur.cwar
		from	tdpur401
		where	tdpur401._index1 = {:g.int.rbid, :1, :2}
		as set with 1 rows
		wherebind (1, lval(pur.pono))
		wherebind (2, lval(pur.sqnb))
		selectdo
			g.int.pono = lval(pur.pono)
		endselect

		if not isspace(pur.item) then
			g.int.item = pur.item
		endif
		if not isspace(pur.cwar) then
			g.int.cwar = pur.cwar
		endif
	endif

	utc.to.local(g.int.crdt, tfgld106.dcdt, dummy.long)

	|* ia?aaanoe aaoo ec UTC a DATE
	utc.to.local(g.int.posd, g.int.posd, dummy.long)

	|* Ii?aaaeyai ciae. Oi?iinou n?aaiaiey 4-?a ciaea iinea caiyoie
	|* ooieoey double.cmp aica?auaao
	|* 0 - anee int.nuni
	|* (-1) - anee int.nuni < 0
	|* (+1) - anee int.nuni > 0
|		inr.qstk = double.cmp(int.nuni, 0.0, 0.0001) * abs(inr.qstk)
	g.inr.qstk = double.cmp(g.int.amnt, 0.0, 0.0001) * abs(g.inr.qstk)

	|* oei i?iaiaee ii?aaaeyai oieuei ii ia?aie iaeaaiiie iia?aoee,
	|* Aey ei??aniiiae?o?uae ?anoe, caienuaa?ony o?a caiieiaiiua a iniiaiie
	|* ?anoe
	if i.process.code <> RECONC.MASK and
	   i.process.code <> RECONC.MASK.TRF
	   or isspace(g.int.itpi)
	then

		|* koor_kost_5
		g.int.itpi = ""
		on case g.int.idtc
		case "10060052":
			if g.inr.kost = tckost.receipt then	|* 3
				on case g.inr.koor
				case tckoor.act.sfc: 	g.int.itpi = "SFC_SF_Return" 		break 	|* 	1
				case tckoor.act.pur: 	g.int.itpi = "PUR_ORD_Return" 		break 	|* 	2
				case tckoor.act.asc:	g.int.itpi = "ASC_SF_Return" 		break 	|* 	9
				case tckoor.act.pur.man: g.int.itpi = "PUR_Manual_Return" 	break	|* 33
				case tckoor.act.trf:												|* 22
				case tckoor.act.trf.man: 											|* 36
				case tckoor.enterprise.plan: g.int.itpi = "WH_Transfer" 	break	|* 60
				endcase
			else	|* 5
				on case g.inr.koor
				case tckoor.act.sfc: 	 g.int.itpi = "SFC_MAT_Issue" 		break	|*  1
				case tckoor.act.pur: 	 g.int.itpi = "PUR_SUB_Issue" 		break	|*  2
				case tckoor.act.sls: 	 g.int.itpi = "SAL_ORD_Issue" 		break   |*  3
				case tckoor.act.asc:	 g.int.itpi = "ASC_MAT_Issue" 		break	|*  9
				case tckoor.act.srv:	 g.int.itpi = "SER_MAT_Issue" 		break 	|* 17
				case tckoor.act.sfc.man: g.int.itpi = "SFC_Manual_Issue" 	break	|* 32
				case tckoor.act.sls.man: g.int.itpi = "SAL_Manual_Issue" 	break	|* 34
				case tckoor.act.dpt.wrk.man: g.int.itpi = "WO_Manual_Issue" break	|* 42
				case tckoor.act.asc.man: g.int.itpi = "ASC_Manual_Issue" 	break	|* 46
				case tckoor.act.trf:												|* 22
				case tckoor.act.trf.man: 											|* 36
				case tckoor.enterprise.plan:										|* 60
					if item.is.floor.stock(
						i.fcmp)							|#SH-IPLCINT0011-1.n 
					then
						g.int.itpi = "WH_Transfer_Low"
					else
						|* skip in main select transaction "10060052"
						return(false)
					endif
					break
				endcase
			endif
			break
		case "10061074":
			if g.inr.kost = tckost.receipt then
				on case g.inr.koor
				case tckoor.act.sfc: 	 g.int.itpi = "SFC_SF_Output"		break
				case tckoor.act.asc: 	 g.int.itpi = "ASC_SF_Output"		break
				case tckoor.act.pur: 
					|if read.pur.order(					|#SH-IPLCINT0014-1.so
					|	g.int.orno, tmp.otyp) then
					|	if tmp.otyp = "SBD" then		|#SH-IPLCINT0014-1.eo
														|#SH-IPLCINT0014-1.sn
					if read.pur.subc(g.int.orno,g.int.pono,tmp.subc) then 
						if tmp.subc = tcyesno.yes	then	|#SH-IPLCINT0014-1.en
							g.int.itpi = "PUR_SUB_Receipt"
						else
							g.int.itpi = "PUR_ORD_Receipt"
						endif
					endif
					break
				case tckoor.act.sfc.man: g.int.itpi = "SFC_Manual_Receipt" 	break
				case tckoor.act.dpt.wrk.man: g.int.itpi = "WO_Manual_Receipt" break
				case tckoor.act.asc.man: g.int.itpi = "ASC_Manual_Receipt" 	break
				case tckoor.act.trf:
				case tckoor.act.trf.man:
				case tckoor.enterprise.plan: g.int.itpi = "WH_Transfer" 	break	|* 60
				case tckoor.act.pur.man: g.int.itpi = "PUR_Manual_Receipt" 	break
				endcase
			else
				on case g.inr.koor
				case tckoor.act.sls: 	g.int.itpi = "SAL_ORD_Return" 		break
				case tckoor.act.sfc:	g.int.itpi = "SFC_MAT_Return" 		break
				case tckoor.act.asc: 	g.int.itpi = "ASC_MAT_Return" 		break
				case tckoor.act.srv:	g.int.itpi = "SER_MAT_Return" 		break 	|* 17
				case tckoor.act.trf:
				case tckoor.act.trf.man:
				case tckoor.enterprise.plan: g.int.itpi = "WH_Transfer" 	break	|* 60
				case tckoor.act.sls.man: g.int.itpi = "SAL_Manual_Return" 	break
				endcase
			endif
			break
		case "10061109":
			if g.inr.kost = tckost.issue then
				on case g.inr.koor
				case tckoor.act.sfc: g.int.itpi = "SFC_MAT_Deviations" 	break
				case tckoor.act.asc: g.int.itpi = "ASC_MAT_Deviations"	break
				endcase
			endif
		case "10061038":
		case "10060031":
			if	g.inr.kost = tckost.receipt then
				on case g.inr.koor
				case tckoor.act.pur: g.int.itpi = "PUR_ORD_Deviations" break
				case tckoor.act.pur.man: g.int.itpi = "PUR_Manual_Receipt" 	break
				endcase
			else
				on case g.inr.koor
				case tckoor.act.sls.man: g.int.itpi = "SAL_Manual_Issue" 	break
				endcase
			endif

			break
		case "10001074":
			if double.cmp(g.int.iqan, 0.0, 0.0001) >= 0 then
				g.int.itpi = "PUR_ORD_Receipt"
			else
				g.int.itpi = "PUR_ORD_Return"
			endif
			break
		case "10001065":
		case "50050003":
			g.int.itpi = "PUR_ORD_Deviations"
			break
		case "10061086":
		case "10061087":
			g.int.itpi = "PUR_Internal_Receipt"
			break
		case "10060054":
|		case "10060082":
|		case "10060125":
|		case "10060087":
			g.int.itpi = "SAL_Internal_Issue"
			break
		case "10061090":
			if g.inr.kost = tckost.receipt then
				on case g.inr.koor
				case tckoor.act.pur.man: g.int.itpi = "PUR_Manual_Receipt" 	break
				endcase
			else
				on case g.inr.koor
				case tckoor.act.sls.man: g.int.itpi = "SAL_Manual_Return" 	break
				endcase
			endif
			break
		|case "10062052": |* WH_Transfer_Low
		|	if g.inr.kost = tckost.issue then
		|		on case g.inr.koor
		|		case tckoor.act.trf:
		|		case tckoor.act.trf.man:
		|		case tckoor.enterprise.plan: g.int.itpi = "WH_Transfer_Low" 	break	|* 60
		|		endcase
		|	endif
		|	break
		case "15060052":
			if g.inr.kost = tckost.issue then
				g.int.itpi = "SAL_ORD_Subcontract"
			endif
			break
		case "10060116":
			if g.inr.kost = tckost.issue then
				g.int.itpi = "SAL_SUB_Issue"
			endif
			break
		case "10061117":
			if g.inr.kost = tckost.receipt then
				g.int.itpi = "SAL_SUB_Receipt"
			endif
			break
		case "10055013":
			if g.inr.kost = tckost.stc.correction then
				if double.cmp(g.int.iqan, 0.0, 0.0001) >= 0 then
					g.int.itpi = "COR_INV_Receipt"
				else
					g.int.itpi = "COR_INV_Issue"
				endif
			endif
			break
		case "10054013":
			if g.inr.kost = tckost.stc.correction then
				if double.cmp(g.int.iqan, 0.0, 0.0001) >= 0 then
					g.int.itpi = "COR_Result_Receipt"
				else
					g.int.itpi = "COR_Result_Issue"
				endif
			endif
			break
		|* Oper Costs
		case "10014061":
			g.int.itpi = "SFC_OPR_Post"
			break
		case "10037061":
			g.int.itpi = "ASC_OPR_Post"
			break
		endcase
	endif

	g.inr.qstk = abs(g.inr.qstk)
	g.int.amnt = abs(g.int.amnt)
	g.int.amth = abs(g.int.amth)

	if not pur.case then
		g.int.iqan = g.inr.qstk
	endif

	return(true)
}

function long item.is.floor.stock(
				domain	tcncmp		i.fcmp)
{

	|* return true if whwmd400.pics = Yes
|	return(whwmd.dll0400.item.is.floor.stock(		|#SH-IPLCINT0011-1.so
|				g.int.item,
|				get.compnr()))						|#SH-IPLCINT0011-1.eo

	domain	tcmcs.long	pics.yn							|#SH-IPLCINT0011-1.sn
	
	domain	tcncmp		ref.fcom
	domain	tcreco		ref.reco
	domain	tcrecs		ref.recs
	domain	tcguid		ref.link
	domain	tcboid		cor.rbid
	
	pics.yn	 = whwmd.dll0400.item.is.floor.stock(
				g.int.item,
				get.compnr())	
	
	if pics.yn then 
		|* here only
		|* g.int.idtc = "10060052" and 
		|* g.inr.kost = tckost.issue
		|* g.inr.koor = 
		|* case tckoor.act.trf:	
		|* case tckoor.act.trf.man: 
		|* case tckoor.enterprise.plan:
		
		select	t1.fcom:ref.fcom,
				t1.reco:ref.reco,
				t1.recs:ref.recs,
				t1.link:ref.link
		from	tfgld495 t1
		where	t1._index7 = {	:g.int.lcmp, :g.int.rbon,:g.int.rbid}
		and  	t1.rpon = :g.int.rpon
		and		t1.link <> ""
		and		t1._compnr = :i.fcmp
		group by t1.fcom, t1.reco, t1.recs, t1.link
		selectdo
				select	t2.rbid:cor.rbid
				from	tfgld495 t2
				where	t2._index9 = {:ref.fcom, :ref.reco, :ref.recs, :ref.link}
				and		t2.rbid <> :g.int.rbid
				and		t2.idtc <> :g.int.idtc and t2.idtc <> "10001074"
				and		t2._compnr = :i.fcmp
				and 	t2.idtc = "10062052"
				as set with 1 rows
				selectdo
					return(true)
				endselect
		endselect
	endif
	
	return(false)
													|#SH-IPLCINT0011-1.eo	
}

function long process.reconciliation(
					domain	tcmcs.str13	i.process.code,
					domain	tcncmp		i.fcmp,
					domain	tcncmp		i.lcmp,
					domain	tfgld.ttyp	i.typf,
					domain	tfgld.ttyp	i.typt,
					domain	tfgld.docn	i.docf,
					domain	tfgld.docn	i.doct,
					domain	tcidty		i.idtf,
					domain	tcidty		i.idtt,
					domain	tcbona		i.rbnf,
					domain	tcbona		i.rbnt,
					domain	tcboid		i.rbdf,
					domain	tcboid		i.rbdt,
					domain	tcdate		i.trdf,
					domain	tcdate		i.trdt,
					domain	tckoor		i.koor.f,
					domain	tckoor		i.koor.t,
					domain	tckost		i.kost.f,
					domain	tckost		i.kost.t,
						boolean		i.queue,
						boolean		i.print.report,
						boolean		i.do.insert,
						boolean		i.repeated.export,
				ref		long		io.next.seqn,
				ref		long		io.recs)
|						long		i.check.only)
{
	domain	tcguid		ref.guid
	domain	tfgld.dbcr	ref.dbcr
	domain	tcncmp		ref.fcom
	domain	tcreco		ref.reco
	domain	tcrecs		ref.recs
	domain	tcguid		ref.link
	domain	tcboid		ref.rbid
	domain	tcbona		rbnf fixed, rbnt fixed
	domain	tcboid		rbdf fixed, rbdt fixed

	domain	tcguid		cur.issue.list
		long			sql.id
		long			sql.trf.id
		String			sql.str(8192)

	domain	tcmcs.str100	add.where.start


		|domain	tcmcs.str100	add.where.start


	rbnf = ""
	rbdf = ""
	set.fmax(rbnt, "tcbona")
	set.fmax(rbdt, "tcboid")


	|if g.new.sql.query then
	|	sql.id = 0
	|	sql.trf.id = 0
	|	g.new.sql.query = false
	|endif

	|select	t1.fcom:ref.fcom,
	|		t1.reco:ref.reco,
	|		t1.recs:ref.recs,
	|		t1.link:ref.link
	|from	tfgld482 t0, tfgld495 t1
	|where	t0._index2 = {	:tfgld106.ocmp, :g.int.rbon,
	|			:g.int.rbid, :g.int.rpon}
	|and	t0.trdt = :tfgld482.trdt|* tfgld482.trdt
	|and	t0._compnr = :i.fcmp
	|and	t1._index1 = {t0.guid, t0.dbcr}
	|and	t1.link <> ""
	|and	t1._compnr = :i.fcmp
	|group by t1.fcom, t1.reco, t1.recs, t1.link
	|selectdo

	select	t1.fcom:ref.fcom,
			t1.reco:ref.reco,
			t1.recs:ref.recs,
			t1.link:ref.link
	from	tfgld495 t1
	|where	t1._index7 = {	:tfgld106.ocmp, :g.int.rbon,:g.int.rbid}
	where	t1._index7 = {	:g.int.lcmp, :g.int.rbon,:g.int.rbid}
	and  	t1.rpon = :g.int.rpon
	and		t1.link <> ""
	and		t1._compnr = :i.fcmp
	|and		t1._compnr = :g.int.lcmp
	group by t1.fcom, t1.reco, t1.recs, t1.link
	selectdo

		|if TRF.RECEIPT or TRF.ISSUE.LOW then
|		if WH.TRANSFER then |#SH-IPLCINT007-1.o		|#SH-IPLCINT0011-1.n
		if WH.TRANSFER and 	|#SH-IPLCINT007-1.sn	|#SH-IPLCINT0011-1.so	
			g.int.itpi <> "WH_Transfer_Low"	
		then				|#SH-IPLCINT007-1.en	|#SH-IPLCINT0011-1.eo
		
			create.transfer.order.mapping(
					i.fcmp,
					ref.fcom,
					ref.reco,
					ref.recs,
					ref.link)
			|* aey ia?aiauaiey eniieucoaony niaoeaeuiay eiaeea.
			cur.issue.list =
				create.transfer.issue.guid.list.2(
					i.fcmp,
					ref.fcom,
					ref.reco,
					ref.recs,
					ref.link,
					i.do.insert)
					|i.check.only)
			|if i.check.only and not isspace(cur.issue.list) then
			|	return(false)
			|endif

			|* Anee ia iaoee niioaaonoao?uo? noiio, oi euai aaeuoa.
			if isspace(cur.issue.list) then
				continue
			endif

			select 	twsap108.*
			from	twsap108
			where	twsap108._index1 = {:g.inr.koor,:g.int.orno,:g.int.pono}
			  and 	twsap108.rbid = :g.int.rbid				|#SH-IPLCINT0011-1.o
|			  and 	(twsap108.rbid = :g.int.rbid or 		|#SH-IPLCINT0011-1.sn
|	         		 twsap108.rbid.cor = :g.int.rbid and 
|			 		 twsap108.itpi	= "WH_Transfer_Low")	|#SH-IPLCINT0011-1.en
			selectdo
				dll0106.unid = toupper$(uuid.generate$())
				io.recs = io.recs + io.next.seqn
				io.next.seqn = 0

				|add.where.start = sprintf$(
				|		" tfgld482._index2  = {%d} " &
				|		" and twsap110.seqn = {%d} ",
				|		i.lcmp , twsap108.seqn)

				|if sql.trf.id = 0 then
					add.where.start = sprintf$(
							" tfgld482._index2  = {%d} " &
							" and twsap110.seqn = {:511} ",
							i.lcmp)

					sql.str = get.integration.sql(
							RECONC.MASK.TRF,
							cur.issue.list,
							i.fcmp, i.lcmp, i.typf, i.typt,
							i.docf, i.doct, i.idtf, i.idtt,
							rbnf, rbnt, rbdf, rbdt,
							i.trdf, i.trdt,
							i.koor.f, i.koor.t,
							i.kost.f, i.kost.t,
							i.queue,
							add.where.start)

						twsap.dll0116.print.tech.report(sql.str)

					sql.trf.id = sql.parse(sql.str)
				|endif

				e = sql.where.bind(sql.trf.id,510, cur.issue.list)
				e = sql.where.bind(sql.trf.id,511, twsap108.seqn)

				bind.integration.variables(RECONC.MASK.TRF, sql.trf.id)
				e = sql.exec(sql.trf.id)

				while not sql.fetch(sql.trf.id)
						|* caiaiyai noiiu e eiee?anoaa ia aaiiua ec i?iaiaee
						g.int.amnt = twsap108.amnt
						g.int.amth = twsap108.amth
						g.inr.qstk = twsap108.quan
						g.int.itpi = twsap108.itpi

						preprocess.integration.selectdo(RECONC.MASK.TRF,i.fcmp)
						twsap.dll0116.process.integration.selectdo(
								RECONC.MASK.TRF,
								g.int.amnt,
								g.int.amth,
								i.print.report,
								i.do.insert,
								i.repeated.export,
								io.next.seqn,
								io.recs)
		|				g.int.pono = 0
				endwhile

				e = sql.break(sql.trf.id)
				e = sql.close(sql.trf.id)
			endselect
			|e = sql.close(sql.trf.id)

			if not isspace(cur.issue.list) then
				clear.guid.list(cur.issue.list)
				break
			endif

		else
			select	t2.guid:ref.guid, t2.dbcr:ref.dbcr
			from	tfgld495 t2
			where	t2._index9 = {:ref.fcom, :ref.reco, :ref.recs, :ref.link}
			and		t2.rbid <> :g.int.rbid
			and		t2.idtc <> :g.int.idtc and t2.idtc <> "10001074"
			|and	t2.rbon <> BO_INVENTORY_TRANSACTION
			and	t2._compnr = :i.fcmp
			|and		t2._compnr = :g.int.lcmp
			as set with 1 rows
			selectdo
				|if sql.id = 0 then
					sql.str = get.integration.sql(
						RECONC.MASK,
						"", |* guid.list
						i.fcmp, i.lcmp, i.typf, i.typt,
						i.docf, i.doct, i.idtf, i.idtt,

		|				i.rbnf, i.rbnt, i.rbdf, i.rbdt,
						rbnf, rbnt, rbdf, rbdt,

						i.trdf, i.trdt,
						i.koor.f, i.koor.t,
						i.kost.f, i.kost.t,
						i.queue,
						|sprintf$("tfgld482._index1 = {%s} ",
						|	quoted.string(ref.guid)))
						"tfgld482._index1 = {:500} ")

					twsap.dll0116.print.tech.report(sql.str)
					sql.id = sql.parse(sql.str)
				|endif

				e = sql.where.bind(sql.id,500,ref.guid)
				bind.integration.variables(RECONC.MASK, sql.id)
				e = sql.exec(sql.id)

				while not sql.fetch(sql.id)
					preprocess.integration.selectdo(RECONC.MASK,i.fcmp)
					twsap.dll0116.process.integration.selectdo(
						RECONC.MASK,
						g.int.amnt,
						g.int.amth,
						i.print.report,
						i.do.insert,
						i.repeated.export,
						io.next.seqn,
						io.recs)
	|				g.int.pono = 0
				endwhile

				e = sql.break(sql.id) + sql.close(sql.id)
			endselect
		endif
	endselect

	return(true)

|	select	t2.guid:ref.guid, t2.dbcr:ref.dbcr
|	from	tfgld482 t0, tfgld495 t1, tfgld495 t2
|	where	t0._index2 = {	:tfgld106.ocmp, :g.int.rbon,
|				:g.int.rbid, :g.int.rpon}
|	and	t0._compnr = :i.fcmp
|	and	t1._index1 = {t0.guid}
|	and	t1.link <> ""
|	and	t1._compnr = :i.fcmp
|	and	t2._index9 = {t1.fcom, t1.reco, t1.recs, t1.link}
|	and	t2.rbon <> BO_INVENTORY_TRANSACTION
|	and	t2._compnr = :i.fcmp
|	as set with 1 rows
|	selectdo
|	endselect
}

function domain	tcguid create.transfer.issue.guid.list(
			domain	tcncmp		i.fcmp,
			domain	tcncmp		i.ref.fcom,
			domain	tcreco		i.ref.reco,
			domain	tcrecs		i.ref.recs,
			domain	tcguid		i.ref.link)
			|		long		i.check.only)
{
	domain	tcguid		o.issue.list
	domain	tcdate		tmp.utc

	domain	tcguid		issue.guid
	domain	tcboid 		issue.rbid
	domain	tcidty		issue.idtc
	domain	tfgld.amnt	issue.amth
	domain	tcmcs.long	issue.count

	o.issue.list = ""

	|select	t2.guid:ref.guid, t2.dbcr:ref.dbcr
	|		from	tfgld495 t2
	|		where	t2._index9 = {:ref.fcom, :ref.reco, :ref.recs, :ref.link}
	|		and		t2.rbid <> :g.int.rbid
	|		|and	t2.rbon <> BO_INVENTORY_TRANSACTION
	|		and	t2._compnr = :i.fcmp
	|		as set with 1 rows
	|		selectdo

	select  t2.rbid:issue.rbid,
			t2.idtc:issue.idtc,
			sum(t2.amth(1)):issue.amth
	from	tfgld495 t2
	where	t2._index9 = {:i.ref.fcom,:i.ref.reco, :i.ref.recs, :i.ref.link}
	and		t2.rbid <> :g.int.rbid
	|and		t2.idtc = "10060052"
	and		t2._compnr = :i.fcmp
	group by t2.rbid, t2.idtc
	selectdo
		|* iaeoe io?iue rbid
		|* n?aaieaaai noiio iinooieaiey e noiio ioionea
		on case issue.idtc
		case "10060052":	|* WH_Transfer
			if not EQUAL.TO(g.int.amth,issue.amth) then
				continue
			endif
		case "10062052":	|* WH_Transfer_Low
			|if i.check.only then
			|	g.int.itpi = "WH_Transfer_Low"
			|	return(g.int.itpi)
			|endif
			break
		default:
			continue
		endcase
		|if issue.idtc <> "10060052" or not EQUAL.TO(g.int.amth,issue.amth) then
		|	continue
		|endif

		select  t2.guid:issue.guid
		from	tfgld495 t2
		where	t2._index9 = {:i.ref.fcom,:i.ref.reco, :i.ref.recs, :i.ref.link}
		and		t2.rbid = :issue.rbid
		|and	t2.idtc = "10060052"
		and		t2._compnr = :i.fcmp
		group by t2.guid
		selectdo
			|* caienaou ana iaeaaiiua GUID ii yoiio rbid
			if isspace(o.issue.list) then
				o.issue.list = toupper$(uuid.generate$())
				tmp.utc = utc.num()
			endif

			twsap110.prid = o.issue.list
			twsap110.guid = issue.guid
			twsap110.date = tmp.utc
			db.insert(ttwsap110,db.retry)
		endselect
		|commit.transaction()
		if not isspace(o.issue.list) then
			break
		endif
	endselect

	return(o.issue.list)
}

function domain	tcguid create.transfer.issue.guid.list.2(
			domain	tcncmp		i.fcmp,
			domain	tcncmp		i.ref.fcom,
			domain	tcreco		i.ref.reco,
			domain	tcrecs		i.ref.recs,
			domain	tcguid		i.ref.link,
					boolean		i.do.insert)
			|		long		i.check.only)
{
	domain	tcguid		o.issue.list
	domain	tcdate		tmp.utc

	domain	tcguid		issue.guid
	domain	tcboid 		issue.rbid
	domain	tcpono		issue.rpon
	domain	tcidty		issue.idtc
	domain	tfgld.amnt	issue.amth
	domain	tcmcs.long	issue.count

	|domain	tcmcs.long	cur.pack

	domain	tcmcs.s100	rep.line

	o.issue.list = ""

	select 	twsap108.*
	from	twsap108 |for update
	where	twsap108._index1 = {:g.inr.koor,:g.int.orno,:g.int.pono}
	|  and 	twsap108.idtc = :g.int.idtc
	   and 	twsap108.rbid = :g.int.rbid 			|#SH-IPLCINT0011-1.o
|	  and 	(twsap108.rbid = :g.int.rbid or 		|#SH-IPLCINT0011-1.sn
|	         twsap108.rbid.cor = :g.int.rbid and 
|			 twsap108.itpi	= "WH_Transfer_Low")	|#SH-IPLCINT0011-1.en
	|  and 	twsap108.rpon = :g.int.rpon
	selectdo
		|* auae?aai eeai iaia?aaioaiiua, eeai anee oanoiaue ?a?ei, oi ana
		|if twsap108.prcd <> tcyesno.yes or not i.do.insert then
		|	cur.pack = cur.pack + 1
			select  t2.rbid:issue.rbid,
					t2.rpon:issue.rpon,
					t2.idtc:issue.idtc,
					t2.guid:issue.guid
			from	tfgld495 t2
			where	t2._index9 = {:i.ref.fcom,:i.ref.reco, :i.ref.recs, :i.ref.link}
			and		t2._compnr = :i.fcmp
			group by t2.rbid, t2.rpon, t2.idtc, t2.guid
			selectdo
				|* A oaeouee iaeao caienuaaai iaio i?iaiaeo
				if (twsap108.idtc 	  = issue.idtc and
					twsap108.rbid 	  = issue.rbid and
					twsap108.rpon 	  = issue.rpon
					) or
				   (twsap108.idtc.cor = issue.idtc and
				    twsap108.rbid.cor = issue.rbid and
				    twsap108.rpon.cor = issue.rpon)
				then
					|select  t2.guid:issue.guid
					|from	tfgld495 t2
					|where	t2._index9 = {:i.ref.fcom,:i.ref.reco, :i.ref.recs, :i.ref.link}
					|and		t2.rbid = :issue.rbid
					|and		t2.rpon = :issue.rpon
					|and		t2._compnr = :i.fcmp
					|group by t2.guid
					|selectdo
						|if (twsap108.idtc 	  = issue.idtc) or
				   		|   (twsap108.idtc.cor = issue.idtc)
						|then
							|* caienaou ana iaeaaiiua GUID ii yoiio rbid
							if isspace(o.issue.list) then
								o.issue.list = toupper$(uuid.generate$())
								tmp.utc = utc.num()
							endif

							twsap110.prid = o.issue.list
							twsap110.seqn = twsap108.seqn
							twsap110.guid = issue.guid
							twsap110.rbid = issue.rbid

							rep.line = concat$("~",
										twsap110.prid,
										twsap110.seqn,
										twsap110.guid,
										twsap110.rbid
										)
							twsap.dll0116.print.tech.report(rep.line)

							twsap110.date = tmp.utc 
							db.insert(ttwsap110,db.retry,db.skip.dupl)
							|if i.do.insert then
							|	twsap108.prcd = tcyesno.yes
							|	db.update(ttwsap108,db.retry)
							|endif
						|endif
					|endselect
				endif
			endselect
		|endif
	endselect
	commit.transaction()
	return(o.issue.list)
}

function extern twsap.dll0116.process.integration.selectdo(
					domain	tcmcs.str13	i.process.code,
					|domain	tcqiv1		i.qstk,
					|domain	tcncmp		i.lcmp,	|* eiaenoe?aneay eiiiaiey
					domain	tfgld.amnt	i.amnt,
					domain	tfgld.amnt	i.amth,
						boolean		print.report,
						boolean		do.insert,
						boolean		i.repeated.export,
				ref		long		io.next.seq,
				ref		long		io.recs)
{
		long	tmp.tot.count

		string 	mess.text(100)
|	boolean		repeated.export
|
|	repeated.export = false
|	if get.argc() >= 9 then
|		repeated.export = get.boolean.arg(9)
|	endif

	|* oaaee?eaaai n?ao?ee caienae
	|io.recs = io.recs + 1

|	|* ?acai?a?eaaai noiio aey e?aaeoiaie no?iee
|	g.int.iqan = i.qstk * (tfgld106.dbcr = tfgld.dbcr.debit ? 1 : -1)

	|* ii?aaaeyai caeoiee eee i?iecaiaonai
|	g.int.bwtar = i.fcmp = 201 ? "PRD" : "PUR"
	on case i.process.code
	case RECONC.MASK:
	case "twsap1206m100":
		g.int.bwtar = "PUR"
		select	whina124.ccpt from whina124
		|where	whina124._index2 = {:g.int.itid}
		|and	whina124.itse = :g.int.itse
		where	whina124._index2 = {:g.int.rbid}
		and		whina124.itse = :g.int.rpon
		|and	whina124._compnr = :i.lcmp
		and	exists (select	tcmcs048.cref from tcmcs048
				where	tcmcs048._index1 = {whina124.ccpt}
				and	tcmcs048.cref = tccref.operation)
		as set with 1 rows
		selectdo
			g.int.bwtar = "PRD"
		endselect
		break
	endcase

	tfgld106.amnt = i.amnt

	|* iaioeyai iannea aae?o iannea e o?ao noii
	set.mem(tfgld106.amth, 0.0)
	|* caiieiaiea ?oaeaaie noii
	tfgld106.amth(1) = i.amth

	|* caienu no?iee ia ?anoe?aiiue aooa?
	fill.storage.record.buffer(
		i.process.code,
		io.next.seq,
		false,
		print.report,
		do.insert)
		|i.repeated.export)

	tmp.tot.count = io.recs+io.next.seq
	if do.insert then
		|* caaa?oaiea o?aicaeoee i?e niaia iiia?a aieoiaioa
		|* dll0106.unid
		|COMMIT.100(tmp.tot.count)
	endif
	|* a iiaaae naaina aiaaaeai auaia eiee?anoaa ia?aaioaiiuo caienae
	|if g.max.pack.guid <> 0 then
	|	mess.text = sprintf$("comp=%1$d,rec=%4$d",
	|				get.compnr(),
	|				tmp.tot.count)

		|mess.text = sprintf$("comp=%1$d,pack=%2$d/%3$d; rec=%4$d",
		|					get.compnr(),
		|					g.cur.pack,
		|					g.max.pack.guid,
		|					tmp.tot.count)
	|else
		mess.text = sprintf$("comp=%d,rec=%d",get.compnr(),tmp.tot.count)
	|endif

	show.progress.indicator(1,mess.text,tmp.tot.count)
}

function extern twsap.dll0116.generate.integration.queue(
					domain	tcmcs.str13	i.process.code,
					domain	tcncmp		i.fcmp,
					domain	tcncmp		i.lcmp,
					domain	tfgld.ttyp	i.typf,
					domain	tfgld.ttyp	i.typt,
					domain	tfgld.docn	i.docf,
					domain	tfgld.docn	i.doct,
					domain	tcidty		i.idtf,
					domain	tcidty		i.idtt,
					domain	tcbona		i.rbnf,
					domain	tcbona		i.rbnt,
					domain	tcboid		i.rbdf,
					domain	tcboid		i.rbdt,
					domain	tcdate		i.trdf,
					domain	tcdate		i.trdt,
					domain	tccwar		i.cwrf,
					domain	tccwar		i.cwrt,
|					domain	tckoor		i.koor,
|					domain	tckost		i.kost,
					domain	tckoor		i.koor.f,
					domain	tckoor		i.koor.t,
					domain	tckost		i.kost.f,
					domain	tckost		i.kost.t,

						boolean		i.comm,
				ref		long		io.recc)
{
			long	rec.482.find						|#SH-IPLCINT0011-1.n
	domain	tcncmp		curr.comp
	domain	tfgld.date	docd.f, docd.t
		String		sql.str(8192)
		String		test.sql.str(8192)
		long		dummy.long, sql.id, fetch.result|, sq2.id
		String		sql.110.str(8192)
		long		sql.110.id

	utc.to.local(i.trdf, docd.f, dummy.long)
	utc.to.local(i.trdt, docd.t, dummy.long)

	curr.comp	= get.compnr()
	g.process.name = "Generate queue"
	prog.ind = 0

	if i.comm then
		db.retry.point()
	endif

|	io.recc = 0
	on case i.process.code
	case "twsap1206m100":
		if 1 then
			|* i?iaa?y? iiaue aeai?eoi
			sql.str = ""
			sql.110.str =
				" select whinr110.itid,whinr110.itse,whinr110.orno,whinr110.pono," &
				       " whinr110.koor,whinr110.kost,whinr110.cwar,whinr110.trdt " &
				" from	 whinr110 " &
				" where " &
						sprintf$(" whinr110.trdt inrange %d and %d ",
							i.trdf, i.trdt) &
				get.koor.kost.statement("whinr110",
							i.koor.f, i.koor.t,
							i.kost.f, i.kost.t) &
				ADD.FILTER.STR("whinr110.itid", "tcboid",   i.rbdf, i.rbdt) &
				" group by whinr110.itid,whinr110.itse,whinr110.orno,whinr110.pono," &
				         " whinr110.koor,whinr110.kost,whinr110.cwar,whinr110.trdt "

			twsap.dll0116.print.tech.report(sql.110.str)
			sql.110.id = sql.parse(sql.110.str)
			e = sql.exec(sql.110.id)
			|* nia?aea oeeuo?o? ii whinr110.itid
			sql.id = 0
			while not sql.fetch(sql.110.id)
				if not check.warehouse(
								whinr110.cwar,whinr110.orno,whinr110.pono,
								whinr110.koor,whinr110.kost,i.cwrf,i.cwrt) then
					|* aa?ai neaao?uo? caienu
					continue
				endif
				|if isspace(sql.str) then
				|if sql.id = 0 then
					|* sql cai?in niae?aai oieuei ia?aue ?ac.
					|* caoai a o?a nia?aiiue cai?in iianiauaaai io?iue whinr110.itid
					sql.str =
							sprintf$(
							"select	tfgld482.fcom, "&
							"   tfgld482.guid, tfgld482.idtc, "&
							"	tfgld482.rbon, tfgld482.rbid, "&
							"	tfgld482.rpon, " &
							"	tfgld482.ttyp, tfgld482.docn, "&
							"	tfgld482.trdt " &
							" from	tfgld482 " &
							" where " &
							" tfgld482._compnr = %1$d " &
							" and  tfgld482._index4 = {%1$d} ",
							|" and  tfgld482.rbid = :1",
							i.fcmp)

					if trim$(i.rbnf) = trim$(i.rbnt) then
						sql.str = sql.str & sprintf$(
							" and tfgld482._index2 = {%1$d,'%2$s',:1,:2} ",
							i.lcmp,i.rbnf)
					else
						sql.str = sql.str & sprintf$(
							" and tfgld482._index2 inrange {%1$d,'%2$s',:1,:2} " &
												" and  {%1$d,'%3$s',:1,:2} ",
							i.lcmp,i.rbnf,i.rbnt)
					endif
					sql.str = sql.str &
						|* aiienuaaai oeeuo aey aua?aiiie oaaeeou twsap109/tfgld482
						ADD.FILTER.STR("tfgld482.idtc", "tcidty",   i.idtf, i.idtt) &
						|ADD.FILTER.STR("tfgld482.rbon", "tcbona",   i.rbnf, i.rbnt) &
						ADD.FILTER.STR("tfgld482.ttyp", "tfgld.ttyp",i.typf,i.typt) &
						ADD.FILTER.L("tfgld482.docn", "tfgld.docn", i.docf, i.doct)

					sql.str = sql.str & twsap.dll0116.idtc.query(
						true,	| aiaaaeou and aia?aea
						i.koor.f, i.koor.t,
						i.kost.f, i.kost.t,
						i.process.code,
						"tfgld482")

					twsap.dll0116.print.tech.report(sql.str)

					sql.id = sql.parse(sql.str)
				|endif
				|* a nia?aiiue cai?in iianiauaaai whinr110.itid
				twsap.dll0116.print.tech.report(whinr110.itid)
				e = sql.where.bind(sql.id,  1, whinr110.itid)
				e = sql.where.bind(sql.id,  2, whinr110.itse)
				e = sql.exec(sql.id)
				
				on.change.check(io.recc)
				rec.482.find = false						|#SH-IPLINT0011-1.n
				while not sql.fetch(sql.id)
					rec.482.find = true						|#SH-IPLINT0011-1.n
					|io.recc = io.recc + 1					|#SH-IPLINT008-1.o
					if i.comm then
						if 									|#SH-IPLINT008-1.n
						twsap.dll0116.update.integration.queue(
							tfgld482.fcom,
							tfgld482.guid, tfgld482.idtc,
							tfgld482.rbon, tfgld482.rbid,
							tfgld482.rpon,
							tfgld482.ttyp, tfgld482.docn,
							tfgld482.trdt)
						then 								|#SH-IPLINT008-1.sn
							io.recc = io.recc + 1			|#SH-IPLINT008-1.en
							COMMIT.1000(io.recc)
						endif								|#SH-IPLINT008-1.n
					endif

					|* a iiaaae naaina aiaaaeai auaia eiee?anoaa ia?aaioaiiuo caienae
					show.progress.indicator(0,
						sprintf$("comp=%d,rec=%d",i.lcmp,io.recc),io.recc)

				endwhile
				|* anee iao aaiiuo a tfgld482, oi caienuaaai oaeie rbid
				|* a i?a?aau n oneiaiui GUID = ZERO_PRICE
				if not rec.482.find then 					|#SH-IPLCINT0011-1.n
				|if not changed(io.recc) then 				|#SH-IPLCINT0011-1.o
					|io.recc = io.recc + 1					|#SH-IPLINT008-1.o
					db.set.to.default(ttfgld482)
					if i.comm then
						
						tfgld482.guid = concat$("/",
								ZERO_PRICE,
								whinr110.itid,
								whinr110.itse) 
						tfgld482.idtc = ZERO_PRICE_IDTC
						tfgld482.rbon = "whinr110"
						tfgld482.rbid = whinr110.itid
						tfgld482.rpon = whinr110.itse
						tfgld482.trdt = whinr110.trdt
						if 									|#SH-IPLINT008-1.n
						twsap.dll0116.update.integration.queue(
							i.fcmp,
							tfgld482.guid, tfgld482.idtc,
							tfgld482.rbon, tfgld482.rbid,
							tfgld482.rpon,
							tfgld482.ttyp, tfgld482.docn,
							tfgld482.trdt)
						then 								|#SH-IPLINT008-1.sn
							io.recc = io.recc + 1			|#SH-IPLINT008-1.en 
							COMMIT.1000(io.recc)
						endif								|#SH-IPLINT008-1.n
					endif
				endif
				|* aoaai iiaoi?ii eniieuciaaou cai?in
				e = sql.break(sql.id)
				|* oaaeaiea sql.id aei?aiiiai cai?ina ii tfgld482
				e = sql.close(sql.id)
			endwhile
			
			sql.id = 0
			e = sql.break(sql.110.id) + sql.close(sql.110.id)
			if i.comm then
				commit.transaction()
			endif
			|* auoiaei ec ooieoee
			close.progress.indicator()
			return
		else
			|create.guid.list
			sql.str =
				"select	tfgld482.fcom, "&
				"   tfgld482.guid, tfgld482.idtc, "&
				"	tfgld482.rbon, tfgld482.rbid, "&
				"	tfgld482.rpon, " &
				"	tfgld482.ttyp, tfgld482.docn, "&
				"	tfgld482.trdt "
			sql.str = sql.str &
					"from	 whinr110, tfgld482 " & |, whina124 "&
					"where " &
						sprintf$(" whinr110.trdt inrange %d and %d ",
							i.trdf, i.trdt) &
						get.koor.kost.statement("whinr110",
							i.koor.f, i.koor.t,
							i.kost.f, i.kost.t)

			|* a caaeneiinoe io caiouaiiiai i?ioanna, ia?aie?eaaai auai?eo ii
			|* oeiai eioaa?aoeiiiuo aieoiaioia
			sql.str = sql.str & twsap.dll0116.idtc.query(
					true,	| aiaaaeou and aia?aea
					i.koor.f, i.koor.t,
					i.kost.f, i.kost.t,
					i.process.code,
					"tfgld482")
				|sprintf$("tfgld482._index2 = {%1$d} " &
					|		" and  tfgld482._compnr = %2$d " &
					|		" and  tfgld482._index4 = {%2%d} ",
					|		i.lcmp,i.fcmp)
			|* i?eciae ?oi oeeuo?oai ii eioaa?aoee

			|* aiienuaaai oeeuo aey aua?aiiie oaaeeou twsap109/tfgld482
			sql.str = sql.str &
				ADD.FILTER.STR("tfgld482.idtc", "tcidty",   i.idtf, i.idtt) &
				ADD.FILTER.STR("tfgld482.rbon", "tcbona",   i.rbnf, i.rbnt) &
				ADD.FILTER.STR("tfgld482.rbid", "tcboid",   i.rbdf, i.rbdt) &
				ADD.FILTER.STR("tfgld482.ttyp", "tfgld.ttyp",i.typf,i.typt) &
				ADD.FILTER.L("tfgld482.docn", "tfgld.docn", i.docf, i.doct)
			|sql.str = sql.str & sprintf$(
			|			get.koor.kost.statement("whinr110",
			|				i.koor.f, i.koor.t,
			|				i.kost.f, i.kost.t) &
			|			"and  whinr110.trdt inrange %d and %d "&
			|			" and whinr110.itid = tfgld482.rbid " &,
			|			i.trdf, i.trdt)
			sql.str = sql.str & sprintf$(
						" and  tfgld482._index2 = {%1$d} " &
						" and  tfgld482._compnr = %2$d " &
						" and  tfgld482._index4 = {%2$d} " &
						" and  tfgld482.rbid = whinr110.itid ",
						i.lcmp,i.fcmp)


			|sql.str = sql.str &
			|		" hint   ordered " &
			|		" and buffer 100 rows "
		endif
		break
	case "twsap1206m200":
		if 1 then
			sql.str = sql.str &
				"from	ticst300,tfgld482,tfgld100 " &
				sprintf$("where ticst300._compnr = %1$d " &
						" and tfgld482._index2 = {%1$d} " &
						" and ticst300._index2 = 61 " &
						|" and ticst300._index2 inrange {61,%3$d} " &
						|						  "and {61,%4$d} " &
						" and tfgld482._compnr = %2$d " &
						" and tfgld482._index1 = ticst300.guid " &
						" and tfgld482.sint = tfgld.ints.posted "&
						" and tfgld100._compnr = %1$d "&
						" and tfgld100._index1 = {tfgld482.fyer,tfgld482.btno} " &
						" and tfgld100.stat = tfgld.bstt.term ",
						i.lcmp,i.fcmp)

			test.sql.str = ADD.FILTER.L("ticst300.trdt", "tcdate", i.trdf, i.trdt)

			if isspace(test.sql.str) then
				sql.str = sql.str &
					" and ticst300._index2 = 61 "
			else
				sql.str = sql.str &
					sprintf$(" and ticst300._index2 " &
								  "inrange {61,%d} " &
									  "and {61,%d} ",
									i.trdf, i.trdt)
			endif
			sql.str = sql.str &
				ADD.FILTER.STR("tfgld482.idtc", "tcidty",   i.idtf, i.idtt) &
				ADD.FILTER.STR("tfgld482.rbon", "tcbona",   i.rbnf, i.rbnt) &
				ADD.FILTER.STR("tfgld482.rbid", "tcboid",   i.rbdf, i.rbdt) &
				ADD.FILTER.STR("tfgld482.ttyp", "tfgld.ttyp",i.typf, i.typt) &
				ADD.FILTER.L("tfgld482.docn", "tfgld.docn", i.docf, i.doct)
		else
			sql.str = sql.str &
			"from	tfgld482 " &
			sprintf$("where tfgld482._index2 = {%d} " &
					" and  tfgld482._compnr = %d " ,
					i.lcmp,i.fcmp)
			|* eniieucoai oeeuo? ii eiaaeno
			test.sql.str =
					(ADD.FILTER.STR("tfgld482.ttyp", "tfgld.ttyp",i.typf,i.typt) &
					ADD.FILTER.L("tfgld482.docn", "tfgld.docn", i.docf, i.doct))
			if isspace(test.sql.str) then
				|* i?iaoai oa?aou eeoiee eiaaen ii oeiainiaie eiiiaiee
				|sql.str = sql.str &
				|		sprintf$(" and  tfgld482._index4 = {%d} ",i.fcmp)
			else
				sql.str = sql.str &
					sprintf$(" and  tfgld482._index4 inrange {%d,%s,%d} and {%d,%s,%d} ",
				          i.fcmp,quoted.string(i.typf), i.docf,
				          i.fcmp,quoted.string(i.typt), i.doct)
			endif
			sql.str = sql.str &
				" and   tfgld482.sint = tfgld.ints.posted " &
				ADD.FILTER.STR("tfgld482.idtc", "tcidty",   i.idtf, i.idtt) &
				ADD.FILTER.STR("tfgld482.rbon", "tcbona",   i.rbnf, i.rbnt) &
				ADD.FILTER.STR("tfgld482.rbid", "tcboid",   i.rbdf, i.rbdt) &
				ADD.FILTER.L("tfgld482.trdt", "tcdate",     i.trdf, i.trdt)| &

			sql.str = sql.str & twsap.dll0116.idtc.query(
				true,	| aiaaaeou and aia?aea
				i.koor.f, i.koor.t,
				i.kost.f, i.kost.t,
				i.process.code,
				"tfgld482")
		endif
		break
	endcase

	|sql.str = sql.str & twsap.dll0116.idtc.query(
	|			true,	| aiaaaeou and aia?aea
	|			i.koor.f, i.koor.t,
	|			i.kost.f, i.kost.t,
	|			i.process.code,
	|			"tfgld482")

	on case i.process.code
	case "twsap1206m200":
		sql.str = sql.str & " order by tfgld482.guid "
		break
	endcase

	twsap.dll0116.print.tech.report(sql.str)
	sql.id = sql.parse(sql.str)
	e = sql.exec(sql.id)
	repeat
		fetch.result = sql.fetch(sql.id)
		on case fetch.result
		case eendfile:
			if i.comm then
				commit.transaction()
			else
				abort.transaction()
			endif
			break
		case 0:
			if i.comm then
				if 											|#SH-IPLINT008-1.n 
				twsap.dll0116.update.integration.queue(
					tfgld482.fcom,
					tfgld482.guid, tfgld482.idtc,
					tfgld482.rbon, tfgld482.rbid,
					tfgld482.rpon,
					tfgld482.ttyp, tfgld482.docn,
					tfgld482.trdt)
				then 										|#SH-IPLINT008-1.sn
					io.recc = io.recc + 1					|#SH-IPLINT008-1.en
					COMMIT.1000(io.recc)
				endif										|#SH-IPLINT008-1.n
			endif
			|io.recc = io.recc + 1							|#SH-IPLINT008-1.n 

			|* a iiaaae naaina aiaaaeai auaia eiee?anoaa ia?aaioaiiuo caienae
			show.progress.indicator(0,
				sprintf$("comp=%d,rec=%d",i.lcmp,io.recc),io.recc)

			if i.comm then
				if io.recc \ 100 = 0 then
					commit.transaction()
				endif
			endif

|			endwhile
|			e = sql.break(sq2.id) + sql.close(sq2.id)
			break
		endcase
	until fetch.result <> 0

	e = sql.break(sql.id) + sql.close(sql.id)

	close.progress.indicator()
}

function boolean check.warehouse(
			domain	tccwar	i.cwar,
			domain	tcorno	i.orno,
			domain	tcpono	i.pono,
			domain	tckoor	i.koor,
			domain	tckost	i.kost,
			domain	tccwar	i.cwrf,
			domain	tccwar	i.cwrt)
{
	|domain	tccwar	tmp.cwar
	domain	tccwar	tmp.sfco
	domain	tccwar	tmp.stco
	domain  tctyps	tmp.sfty 
	domain	tctyps	tmp.stty
	domain	tccwoc	tmp.cwoc, tmp.wdep
	domain	tccotp	tmp.otyp

	static	domain	tccwar	save.cwar
	static	domain	tcorno	save.orno
	static	domain	tcorno	save.cwrf
	static	domain	tcorno	save.cwrt
	static			boolean	save.ret

	|		domain	tcwset	orno.oset

	|* aey yoiai oeia caeaca ia ia i?iaa?you neeaa ii neeaaneiio caeaco
	|* iioiio ?oi neeaaneiai caeaca iao
	|if i.koor = tckoor.adjustment then
	|	return(true)
	|Endif


	if save.orno = i.orno and
	   trim$(save.cwar) = trim$(i.cwar) and
	   trim$(save.cwrf) = trim$(i.cwrf) and
	   trim$(save.cwrt) = trim$(i.cwrt)
	then
		return(save.ret)
	endif

	save.orno = i.orno
	save.cwar = i.cwar
	save.cwrf = i.cwrf
	save.cwrt = i.cwrt
	save.ret = false

	if	i.koor = tckoor.act.trf or
		i.koor = tckoor.act.trf.man or
		i.koor = tckoor.enterprise.plan
	then
		|orno.oset = 1
		|if i.kost = tckost.receipt then
		|	select 	whinh210.oset:orno.oset
		|	from	whinh210
		|	where	whinh210._index1 = {:1, :i.orno, :i.pono}
		|	as set with 1 rows
		|	wherebind (1, whinh.dll0000.convert.koor.to.oorg(i.koor))
		|	selectdo
		|	endselect
		|else
		|	select 	whinh220.oset:orno.oset
		|	from	whinh220
		|	where	whinh220._index1 = {:1, :i.orno, :i.pono}
		|	as set with 1 rows
		|	wherebind (1, whinh.dll0000.convert.koor.to.oorg(i.koor))
		|	selectdo
		|	endselect
		|endif
        |
		|select	whinh200.sfco:tmp.cwar
		|from	whinh200
		|where	whinh200._index1 = {:1, :i.orno,:orno.oset}
		|  and 	(whinh200.sfco inrange {:i.cwrf} and {:i.cwrt} or
		|  		 whinh200.stco inrange {:i.cwrf} and {:i.cwrt})
		|as set with 1 rows
		|wherebind (1, whinh.dll0000.convert.koor.to.oorg(i.koor))
		|selectdo
		|	save.ret = true
		|endselect

		if 	read.warehouse.order(
						i.koor,i.kost,
						i.orno,i.pono,
						tmp.sfty,tmp.stty,
						tmp.sfco,tmp.stco,
						tmp.cwoc, tmp.wdep)
		then
			if (trim$(i.cwrf) <= trim$(tmp.sfco) and trim$(tmp.sfco) <= trim$(i.cwrt)) or
			   (trim$(i.cwrf) <= trim$(tmp.stco) and trim$(tmp.stco) <= trim$(i.cwrt))
			then
				save.ret = true
			endif
		endif
	else
		if trim$(i.cwrf) <= trim$(i.cwar) and
		   trim$(i.cwar) <= trim$(i.cwrt)
		then
			save.ret = true
		endif
	endif
	return(save.ret)
}

function extern twsap.dll0116.reset.integration.queue(
					domain	tcmcs.str13	i.process.code,
					domain	tcncmp		i.fcmp,
					domain	tcncmp		i.lcmp,
					domain	tfgld.ttyp	i.typf,
					domain	tfgld.ttyp	i.typt,
					domain	tfgld.docn	i.docf,
					domain	tfgld.docn	i.doct,
					domain	tcidty		i.idtf,
					domain	tcidty		i.idtt,
					domain	tcbona		i.rbnf,
					domain	tcbona		i.rbnt,
					domain	tcboid		i.rbdf,
					domain	tcboid		i.rbdt,
					domain	tcdate		i.trdf,
					domain	tcdate		i.trdt,
					domain	tccwar		i.cwrf,
					domain	tccwar		i.cwrt,
|					domain	tckoor		i.koor,
|					domain	tckost		i.kost,
					domain	tckoor		i.koor.f,
					domain	tckoor		i.koor.t,
					domain	tckost		i.kost.f,
					domain	tckost		i.kost.t,

						boolean		i.comm,
				ref		long		io.recc)
{

	domain	tcncmp		curr.comp
	domain	tfgld.date	docd.f, docd.t
		String		sql.str(8192)
		String		test.sql.str(1024)
		long		dummy.long, sql.id, fetch.result

	utc.to.local(i.trdf, docd.f, dummy.long)
	utc.to.local(i.trdt, docd.t, dummy.long)

	curr.comp	= get.compnr()
	g.process.name = "Reset queue"
	prog.ind = 0

	if i.comm then
		db.retry.point()
	endif

|	io.recc = 0
	sql.str =
		" select 	twsap109.* " &
		" from 		twsap109 for update "
	
	test.sql.str = 									|#SH-IPLCINT008-1.sn
			ADD.FILTER.STR("twsap109.ttyp", "tfgld.ttyp",   i.typf, i.typt) &
			ADD.FILTER.L  ("twsap109.docn", "tfgld.docn",   i.docf, i.doct)
	if isspace(test.sql.str) then
		sql.str = sql.str & 
			sprintf$(
			" where		twsap109._index1 = {%d,%d}" &
			" and		twsap109.proc = tcyesno.yes ",
			i.fcmp,i.lcmp)
	else											|#SH-IPLCINT008-1.en
		sql.str = sql.str & 
			sprintf$(
			" where		twsap109._index1 inrange {%d,%d,%s,%d,0} and {%d,%d,%s,%d,0}" &
			" and		twsap109.proc = tcyesno.yes ",
			i.fcmp,i.lcmp,quoted.string(i.typf), i.docf,
			i.fcmp,i.lcmp,quoted.string(i.typt), i.doct)
	endif											|#SH-IPLCINT008-1.n

	on case i.process.code
	case "twsap1206m100":
	case "twsap1206m200":
		sql.str = sql.str &
			" and twsap109.guid <> '' " &
			ADD.FILTER.STR("twsap109.idtc", "tcidty",   i.idtf, i.idtt) &
			ADD.FILTER.STR("twsap109.rbon", "tcbona",   i.rbnf, i.rbnt) &
			ADD.FILTER.STR("twsap109.rbid", "tcboid",   i.rbdf, i.rbdt) &
			|ADD.FILTER.L("twsap109.docn", "tfgld.docn", i.docf, i.doct) &
			ADD.FILTER.L("twsap109.trdt", "tcdate",     i.trdf, i.trdt) |&
		break
	endcase

	twsap.dll0116.print.tech.report(sql.str)
	sql.str = sql.str & twsap.dll0116.idtc.query(
				true,	| aiaaaeou and aia?aea
				i.koor.f, i.koor.t,
				i.kost.f, i.kost.t,
				i.process.code,
				"twsap109")

	sql.id = sql.parse(sql.str)
	e = sql.exec(sql.id)
	repeat
		fetch.result = sql.fetch(sql.id)
		on case fetch.result
		case eendfile:
			if i.comm then
				commit.transaction()
			else
				abort.transaction()
			endif
			break
		case 0:

			if i.comm then
				twsap109.proc = tcyesno.no
				db.update(ttwsap109,db.retry)
			endif
			io.recc = io.recc + 1

			|* a iiaaae naaina aiaaaeai auaia eiee?anoaa ia?aaioaiiuo caienae
			show.progress.indicator(0,
				sprintf$("comp=%d,rec=%d",i.lcmp,io.recc),io.recc)

			if i.comm then
				if io.recc \ 100 = 0 then
					commit.transaction()
				endif
			endif

			break
		endcase
	until fetch.result <> 0

	e = sql.break(sql.id) + sql.close(sql.id)

	close.progress.indicator()
}

function string get.inrange.sql.statement.string(
						string		i.fldn(50),
						string		i.doma(50),
				ref		string		i.vlfr(),
				ref		string		i.vlto())
{
	string		ret.string(1024), max.vlto(1024)

	ret.string = ""
	set.fmax(max.vlto, i.doma)
	if not isspace(i.vlfr) and strip$(max.vlto) <> strip$(i.vlto) then
		|* inrange or equal
		if i.vlfr = i.vlto then
			ret.string = i.fldn &"="& quoted.string(strip$(i.vlfr))
		else
			ret.string =
				i.fldn &" inrange "&
				quoted.string(strip$(i.vlfr)) &" and "&
				quoted.string(strip$(i.vlto))
		endif
	else
		if isspace(i.vlfr) then
			|* left value is minimal
			if strip$(max.vlto) <> strip$(i.vlto) then
				ret.string =
					i.fldn &" <= "&
					quoted.string(strip$(i.vlto))
			endif
		endif
		if strip$(max.vlto) = strip$(i.vlto) then
			|* right value is maximum
			if not isspace(i.vlfr) then
				ret.string =
					i.fldn &" >= "&
					quoted.string(strip$(i.vlfr))
			endif
		endif
	endif
	return(ret.string)
}

function string get.inrange.sql.statement.long(
						string		i.fldn(50),
						string		i.doma(50),
						long		i.vlfr,
						long		i.vlto)
{
	string		ret.string(1024)
	long		max.vlto

	ret.string = ""
	set.fmax(max.vlto, i.doma)
	if i.vlfr > 0 and i.vlto <> max.vlto then
		|* inrange or equal
		if i.vlfr = i.vlto then
			ret.string = i.fldn &"="& str$(i.vlfr)
		else
			ret.string =
				i.fldn &" inrange "&
				str$(i.vlfr) &" and "& str$(i.vlto)
		endif
	else
		if i.vlfr = 0 then
			|* left value is minimal
			if max.vlto <> i.vlto then
				ret.string = i.fldn &" <= "& str$(i.vlto)
			endif
		endif
		if max.vlto = i.vlto then
			|* right value is maximum
			if i.vlfr > 0 then
				ret.string = i.fldn &" >= "& str$(i.vlfr)
			endif
		endif
	endif
	return(ret.string)
}

function string append.where.statement(string i.line(1024))
{
	if not isspace(i.line) then
		return(" and "& strip$(i.line))
	endif
	return("")
}

function String get.tfgld106.sql(	domain	tfgld.ttyp	i.otyp,
					domain	tfgld.docn	i.odoc)
{
	return (sprintf$(
			"select	tfgld106.ocmp, "&
			"	tfgld106.fyer, "&
			"	tfgld106.fprd, "&
			"	tfgld106.otyp, "&
			"	tfgld106.odoc, "&
			"	tfgld106.olin, "&
			"	tfgld106.osrl, "&
			"	tfgld106.osrn, "&
			"	tfgld106.dcdt, "&
|			"	tfgld106.date, "&
			"	tfgld106.ratd, "&
			"	tfgld106.rate, "&
			"	tfgld106.fact, "&
			"	tfgld106.rtyp, "&
			"	tfgld106.leac, "&
			"	tfgld106.dbcr, "&
			"	tfgld106.ccur, "&
			"	tfgld106.amnt, "&
			"	tfgld106.amth, "&
			"	tfgld106.bpid, "&
			"	tfgld106.ccty, "&
			"	tfgld106.cvat, "&
			"	tfgld106.ctyp, "&
			"	tfgld106.cinv, "&
			"	tfgld106.user, "&
			"	tfgld106.cont, "&
			"	tfgld106.typ1, "&
			"	tfgld106.dim1, "&
			"	tfgld106.refr, "&
			"	tfgld106.ref2 "&
			"from	tfgld106 "&
			"where	tfgld106._index1 = {%s, %d}",
			quoted.string(i.otyp),
			i.odoc))
}

function empty.global.variables() {
	g.int.idtc = ""
	g.int.rbon = ""
	g.int.rbid = ""
	g.int.rpon = 0
	g.int.posd = 0
	g.int.cuni = ""
	g.int.cfod = ""
	g.int.orno = ""
	g.int.item = ""
	g.int.cwar = ""
	g.int.iqan = 0.0
	g.int.bwtar = ""
	g.int.itid = ""
	g.int.itse = 0
	g.int.itpi = ""
	g.int.pono = 0

	g.inv.sfno = ""
	g.inv.sfdt = 0
	g.inv.appr = tfacp.inv.expence
	g.inv.invf = tfyru.invf.l.original
	g.inv.oinv = 0
	g.inv.amti = 0.0
	g.inv.adjn = 0
	g.inv.rcpd = 0

	document.is.storno = false
	g.fyer_st = 0
	g.fprd_st = 0
	g.otyp_st = ""
	g.odoc_st = 0
	g.sfno_st = ""
	g.sfdt_st = 0
	g.posd_st = 0

	g.otyp_or = ""
	g.odoc_or = 0
	g.fyer_or = 0
	g.fprd_or = 0
|	empty.global.storno.origin.fields()


	|* integration preselect guid
	g.guid.selected = false
	g.guid.list = ""
	
	g.inr.rcno	= ""						|#SH-IPLCINT0011-1.sn
	g.inr.rcln  = 0
	g.inr.shpm  = ""						|#SH-IPLCINT0011-1.en


}

|function empty.global.storno.origin.fields() {
|	document.is.storno = false
|	g.fyer_st = 0
|	g.fprd_st = 0
|	g.otyp_st = ""
|	g.odoc_st = 0
|	g.sfno_st = ""
|	g.sfdt_st = 0
|	g.posd_st = 0
|
|	g.otyp_or = ""
|	g.odoc_or = 0
|	g.fyer_or = 0
|	g.fprd_or = 0
|
|	g.cort = ""
|}

function fill.storage.record.buffer(
			domain	tcmcs.str13		i.process.code,
			ref	domain	tcsern		i.seqn,
						boolean		is.approval,
						boolean		print.report,
						boolean		do.insert,
						...)
{
	domain	tcorno		orno
	domain	tcpono		pono, sqnb
	domain	whinh.shpm	rcno
	domain	whinh.sern	rseq

	domain	tfgld.docn	dummy.oinv
	domain	tfgld.amnt	inv.amnt

	domain	tcncmp		tmp.loco
	domain	whinh.pksp	tmp.shpm
	domain	tcguid		tmp.link

	domain	tctyps		tmp.sfty
	domain 	tctyps		tmp.stty
	domain	tccshp		tmp.stco
	domain	tccshp		tmp.sfco
	domain	tccwoc		tmp.cwoc
	domain	tccwoc		tmp.wdep
	domain 	tccotp		tmp.otyp

	domain	tfgld.srno	tmp.vat.osrn
	
	domain 	whinh.shpm 	nakl.num
	domain	tcdate		nakl.pdat

		boolean		need.reverse.update
		boolean		repeated.export
		String		dummy.str
		long		ind

|		long		dcdt.year, dcdt.peri, dcdt.dayn

	static	domain	tcmcs.str30	prv.gld106.key
	static	domain	tccvat		prv.gld106.cvat

	|repeated.export = false
	|if get.argc() >= 5 then
	|	repeated.export = get.boolean.arg(5)
	|endif

	||* not write duplicate records but print report
	|if not isspace(g.int.idtc)
	|   and do.insert
	|   and not repeated.export
	|   and record.exist.twsap116()
	|then
	|	return
	|endif

	need.reverse.update = false
	i.seqn = i.seqn + 1

	|* i?enoea cia?aiee iieae
	db.set.to.default(ttwsap116)

	|* caienuaaai ana oieuei a oeiainiaua eiiiaiee
	|twsap116._compnr = tfgld106.ocmp

	twsap116.unid = dll0106.unid
	twsap116.seqn = i.seqn
	twsap116.ocmp = tfgld106.ocmp
	twsap116.fyer = tfgld106.fyer
	twsap116.fprd = tfgld106.fprd
	twsap116.otyp = tfgld106.otyp
	twsap116.odoc = tfgld106.odoc
	twsap116.olin = tfgld106.olin
	twsap116.osrl = tfgld106.osrl
	twsap116.osrn = tfgld106.osrn
	twsap116.dcdt = tfgld106.dcdt
|	twsap116.date = tfgld106.date
	twsap116.ratd = tfgld106.ratd
	twsap116.rate = tfgld106.rate
	twsap116.ratf = tfgld106.fact
	twsap116.rtyp = tfgld106.rtyp
	twsap116.leac = tfgld106.leac
	twsap116.dbcr = tfgld106.dbcr
	twsap116.ccur = tfgld106.ccur
	twsap116.vcur = virtual.currency(twsap116.ccur)
	twsap116.amnt = tfgld106.amnt
	twsap116.amth = tfgld106.amth
	twsap116.bpid = tfgld106.bpid
	twsap116.ctyp = tfgld106.ctyp
	twsap116.cinv = tfgld106.cinv
	| twsap116.user = tfgld106.user
	twsap116.crus = tfgld106.user
	twsap116.cont = tfgld106.cont

	|* oieuei aey oaeoo?e?iaaiey caeoiie
	IF IS.PROCESS.INVOICING then
		twsap116.fprm = read.leac.exclude()
	endif

	twsap116.idtc = g.int.idtc
	twsap116.rbon = g.int.rbon
	twsap116.rbid = g.int.rbid
	twsap116.rpon = g.int.rpon
	twsap116.posd = g.int.posd
	twsap116.cuni = g.int.cuni
	|twsap116.cfod = g.int.cfod
	twsap116.cfod = tfgld106.dim1
	twsap116.dim4 = tfgld106.dim4
	
	if twsap116.dim4(1;1) = "I" then
		select 	tfgld010.desc:twsap116.iprt 
		from	tfgld010
		where	tfgld010._index1 = {4,:twsap116.dim4}
	|	  and	tfgld010.dimx alike 'I%'
		as set with 1 rows
		selectdo
		endselect
	endif

	if not IS.PROCESS.INTEGRATION then
		twsap116.cpcp = tfgld106.dim3
		if not control.account(i.process.code,twsap116.leac) then
			twsap116.bpid = ""
		endif
	endif

	twsap116.item = g.int.item
	twsap116.cwar = g.int.cwar
	twsap116.iqan = round(g.int.iqan,3,0)
	twsap116.aufnr = g.int.orno
	twsap116.bwtar = g.int.bwtar
	twsap116.itpi = g.int.itpi

|	if g.int.pono > 0 then
|	if	g.inr.koor = tckoor.act.pur and
|		g.inr.kost = tckost.receipt
|	then
|	if 	g.inr.koor <> tckoor.act.sfc and 
|		g.inr.koor <> tckoor.act.asc then
|		if g.int.use.main.orno then
	if g.inr.koor = tckoor.act.asc then
		select tiasc730.clso:twsap116.aufnr
			from tiasc730
			where tiasc730.worn = :twsap116.aufnr
		selectdo
		endselect
	endif
	twsap116.orno = g.int.orno
	twsap116.pono = g.int.pono
|			twsap116.aufnr = ""
|		else
|			twsap116.orno = g.int.orno
|			twsap116.pono = g.int.pono
|			twsap116.aufnr = ""
|		endif
|	endif



	if read.warehouse.order(
						g.inr.koor,g.inr.kost,
						twsap116.orno,twsap116.pono,
						tmp.sfty,tmp.stty,
						tmp.sfco,tmp.stco,
						tmp.cwoc,tmp.wdep)
	then		
		if	WH.TRANSFER then
			if g.inr.kost = tckost.receipt then
				twsap116.pcwar = tmp.sfco
			else
				twsap116.pcwar = tmp.stco
			endif
		else 
|			if 	g.inr.koor = tckoor.act.dpt.wrk.man or 
|				g.inr.koor = tckoor.act.sfc.man or
|				g.inr.koor = tckoor.act.asc.man	then
|				if twsap116.ocmp = 207 or twsap116.ocmp = 208 then
|					twsap116.cfod = tmp.wdep(2;5)
|				endif
|			endif
			if g.inr.kost = tckost.receipt then
				|* Work Center
				if tmp.stty = tctyps.work.center then
					twsap116.pcwar = tmp.stco
				endif
			else
				if tmp.sfty = tctyps.work.center then 
					twsap116.pcwar = tmp.sfco
				endif
			endif
		endif
		
		|if twsap116.leac(1;2) = "08" then 
			twsap116.iord = tmp.cwoc
		|endif

		|orno.oset = 1
		|if i.kost = tckost.receipt then
		|	select 	whinh210.oset:orno.oset
		|	from	whinh210
		|	where	whinh210._index1 = {:1, :twsap116.orno, :g.inr.pono}
		|	as set with 1 rows
		|	wherebind (1, whinh.dll0000.convert.koor.to.oorg(i.koor))
		|	selectdo
		|	endselect
		|else
		|	select 	whinh220.oset:orno.oset
		|	from	whinh220
		|	where	whinh220._index1 = {:1, :twsap116.orno, :i.pono}
		|	as set with 1 rows
		|	wherebind (1, whinh.dll0000.convert.koor.to.oorg(i.koor))
		|	selectdo
		|	endselect
		|endif
		|
		|select	whinh200.sfco:tmp.sfco,
		|		whinh200.stco:tmp.stco
		|from	whinh200
		|where	whinh200._index1 = {:1, :twsap116.orno,:g.inr.pono}
		|as set with 1 rows
		|wherebind (1, whinh.dll0000.convert.koor.to.oorg(g.inr.koor))
		|selectdo
		|	if g.inr.kost = tckost.receipt then
		|		twsap116.pcwar = tmp.sfco
		|	else
		|		twsap116.pcwar = tmp.stco
		|	endif
		|endselect
	endif
	
	if IS.PROCESS.INTEGRATION then
		select	t1.link:tmp.link
		from	tfgld482 t0, tfgld495 t1
		where	t0._index2 = {	:tfgld106.ocmp, :g.int.rbon,
					:g.int.rbid, :g.int.rpon}
		and	t1._index1 = {t0.guid, :twsap116.dbcr}
		as set with 1 rows
		selectdo
			if not isspace(tmp.link) then
				twsap116.tracc = 1
			endif
		endselect
	endif

	|* Caiieiaiea twsap116.itpi (noa?ue aa?eaio), ia auiieiyaony anee
	|* anee caionoeee ec iiaiai naaina twsap1206m100 e cia?aiea g.int.itpi
	|* caiieieeinu
	if not is.approval and isspace(g.int.itpi) then
		on case twsap116.idtc
		case "10060052":
			twsap116.itpi = "SFC_MAT_Issue"
			break
		case "10061074":
			twsap116.itpi = "SFC_MAT_Return"
			break
		case "10061109":
			twsap116.itpi = "SFC_MAT_Deviations"
			break
		endcase
	endif


	|* Caiieiyai cia?aiea aey iaeiaiaie no?iee

	tmp.vat.osrn = 0
	if i.process.code = SALES.INVOICING then
		if tfgld106.osrn = 7 then
			prv.gld106.key = get.gld106.key()
			prv.gld106.cvat = tfgld106.cvat
		else
			if tfgld106.osrn = 8 or tfgld106.osrn = 9 and
				prv.gld106.key = get.gld106.key()
			then
				tfgld106.cvat = prv.gld106.cvat
			endif
		endif

		if tfgld106.osrn = 7 or
		   tfgld106.osrn = 8 or
		   tfgld106.osrn = 9
		then
			tmp.vat.osrn = 7
		endif
	else
		if tfgld106.osrn = 7 then
			tmp.vat.osrn = 7
		endif
	endif
	|if (tfgld106.osrn = 7) then
	if (tmp.vat.osrn = 7) then
		twsap116.cvat = tfgld106.cvat
		select	tfgld110.pvat:twsap116.pvat,
				tfgld110.tbam:twsap116.vtba,
				tfgld110.tbah:twsap116.vtbh
		from	tfgld110
		where	tfgld110._index1 = {
				:tfgld106.ocmp, :tfgld106.otyp,
				:tfgld106.odoc, :tfgld106.olin,
				:tfgld106.osrl}
		  and 	tfgld110._compnr = :tfgld106.ocmp
		as set with 1 rows
		selectdo
			if twsap.dll0116.document.is.sales.invoice(
					tfgld106.otyp, tfgld106.odoc)
			then
				twsap116.vtba = abs(twsap116.vtba)
				for ind = 1 to 3
					twsap116.vtbh(ind) =
						abs(twsap116.vtbh(ind))
				endfor
			endif
		endselect
	endif

	|* ?oaiea aaiiuo ec i?eaeiaeuiie NO ia?aaoaei a ooeioe?
	|* oae eae io?ii aoaao aucaaou aey noi?ii
	|* oieuei aey oaeoo?e?iaaiey
	if isspace(twsap116.idtc) then
		read.invoice.data(
					is.approval,
					tfgld106.otyp,
					tfgld106.odoc,
					twsap116.fyer,
					twsap116.fprd,
					twsap116.sfno, |* ref
					twsap116.sfdt, |* ref
					twsap116.appr, |* ref
					twsap116.invfl,|* ref
					dummy.oinv,	   |* ref
					inv.amnt,	   |* ref
					twsap116.adjn, |* ref
					|twsap116.oinv,|* ref
					twsap116.rcpdl,|* ref
					twsap116.posd) |* ref
	endif

	|* Caienuaaai aaiiua i?eaeiaeuiiai NO aey aieoiaioa noi?ii
	twsap116.fyer_st = g.fyer_st
	twsap116.fprd_st = g.fprd_st
	twsap116.otyp_st = g.otyp_st
	twsap116.odoc_st = g.odoc_st
	twsap116.posd_st = g.posd_st

	|* oieuei aey NO
	if isspace(g.int.idtc) then
		if twsap116.odoc_st <> 0 then
			twsap116.itpi = "INP_MAT_REV"
		else
			on case twsap116.invfl
			case tfyru.invf.l.original:
				twsap116.itpi =  "INP_MAT_INV"
				break
			case tfyru.invf.l.correction:
				twsap116.itpi =  "INP_MAT_CORR"
				break
			case tfyru.invf.l.orig.adjust:
				twsap116.itpi =  "INP_MAT_ISPR"
				break
			case tfyru.invf.l.corr.adjust:
				twsap116.itpi =  "INP_MAT_ISPR"
				break
			endcase
		endif
	endif
	if twsap.dll0116.document.is.sales.invoice(tfgld106.otyp, tfgld106.odoc) then
|		if sales.invoice.is.storno(
|				tfgld106.ocmp,
|				tfgld106.otyp,
|				tfgld106.odoc)
|		then
|			twsap116.itpi = "INR_INV_MAT_ST"
|		else
|			twsap116.itpi = "INR_INV_MAT"
|		endif

		update.amount.signs(	twsap116.amnt, twsap116.amth,
					twsap116.vtba, twsap116.vtbh)
	endif

	update.integr.proc.id()

	|* Caienuaaai aaiiua i?eaeiaeuiiai NO aey ei??aeoe?iai?iuo
	twsap116.fyer_or = g.fyer_or
	twsap116.fprd_or = g.fprd_or
	twsap116.otyp_or = g.otyp_or
	twsap116.odoc_or = g.odoc_or

	|* Anee ei??aeoe?iaea, oi ii?aaaeyai ciae ei??aeoe?iaee
	if twsap116.invfl <> tfyru.invf.l.original then
		if not isspace(g.cort) then
			twsap116.cort = g.cort
		else
			|* ii-oiie?aie? i?enaaeaaai oei = ei?? No ia oaaee?aiea
			twsap116.cort = "INC"
			if LESS.THAN.ZERO(inv.amnt) and not isspace(twsap116.bpid) then
				|* anee iaiuoa ioey, oi ei??.NO ia oiaiuoaiea
				twsap116.cort = "DEC"
				g.cort = twsap116.cort
				need.reverse.update = true
			endif
		endif
	endif


|	if not is.approval then
|		|* ?eoaai oieuei aey NO aey ooaa??aaiey oieuei caienuaaai oi
|		|* ?oi i?i?eoaee
|		select	tfacp100.isup:g.inv.sfno,
|				tfacp100.invd:g.inv.sfdt
|		from	tfacp100
|		where	tfacp100._index4 = {:tfgld106.otyp, :tfgld106.odoc}
|		as set with 1 rows
|		selectdo
|		selectempty
|			select	tfacp200.isup:g.inv.sfno,
|					tfacp200.docd:g.inv.sfdt
|			from	tfacp200
|			where	tfacp200._index1 = {:tfgld106.otyp, :tfgld106.odoc, 0}
|			as set with 1 rows
|			selectdo
|			endselect
|		endselect
|	endif
|	twsap116.sfno = g.inv.sfno
|	twsap116.sfdt = g.inv.sfdt
|
|	|e = num.to.date(twsap116.dcdt, dcdt.year, dcdt.peri, dcdt.dayn)
|	e = num.to.date(twsap116.sfdt, dcdt.year, dcdt.peri, dcdt.dayn)
|	if (dcdt.year <> twsap116.fyer or dcdt.peri <> twsap116.fprd) then
|		dcdt.year = twsap116.fyer
|		dcdt.peri = twsap116.fprd
|		dcdt.dayn = 1
|	endif
|	twsap116.posd = date.to.num(dcdt.year, dcdt.peri, dcdt.dayn)


	if is.approval and not isspace(tfgld106.ref2) then
			|* ?acae?aai nnueeo ii ianea ia eiiiiiaiou
		e = string.scan(
			|* neeaeaaai aaa iiey
			strip$(tfgld106.refr) & strip$(tfgld106.ref2),
			|* ianea aey ?acai?a n ?acaaeeoaeai /
			|* %s - aaiiua oeia "no?iea"
			|* %d - aaiiua oeia "?enei"
			concat$("/", "%s", "%s", "%d", "%d", "%s", "%d", "%s"),
			|* ia?aiaiiua a eioi?ua caienuaa?ony cia?aiey
			dummy.str, orno, pono, sqnb, rcno, rseq, dummy.str)

		|select	whinh312.item:twsap116.item,
		|		whinh312.rcun:twsap116.cuni,
		|		tfacp251.iqan:twsap116.iqan
		|from	whinh312, tfacp251
		|where	whinh312._index1 = {:rcno, :rseq}
		|and 	whinh312._compnr = {tfacp251.loco}
		|and		tfacp251._index1 = {
		|		:tfgld106.ocmp, :tfgld106.ctyp,
		|		:tfgld106.cinv, :tfgld106.ocmp,
		|		whinh312.psno, tfacp.otyp.purchase,
		|		:orno, :pono, :sqnb, :rcno, :rseq}
		|and		tfacp251._compnr = :tfgld106.ocmp

		|select	whinh312.item:twsap116.item,
		|		whinh312.rcun:twsap116.cuni,
		|		tfacp251.iqan:twsap116.iqan
		|from	tfacp251 join whinh312 on
		|		whinh312._compnr = {tfacp251.loco}
		| and 	tfacp251._index1 = {
		|		:tfgld106.ocmp, :tfgld106.ctyp,
		|		:tfgld106.cinv, :tfgld106.ocmp,
		|		whinh312.psno, tfacp.otyp.purchase,
		|		:orno, :pono, :sqnb, :rcno, :rseq}
		|where	whinh312._index1 = {:rcno, :rseq}
		|and		tfacp251._compnr = :tfgld106.ocmp
		|as set with 1 rows
		|selectdo
		|	twsap116.orno = orno
		|	twsap116.pono = pono
		|	twsap116.sqnb = sqnb
		|	twsap116.rcno = rcno
		|	twsap116.rseq = rseq
		|endselect

		select	tfacp251.iqan:twsap116.iqan,
			tfacp251.loco:tmp.loco,
			tfacp251.shpm:tmp.shpm
		from	tfacp251
		where 	tfacp251._index1 = {
				:tfgld106.ocmp, :tfgld106.ctyp,
				:tfgld106.cinv, :tfgld106.ocmp,
				tfacp251.shpm, tfacp.otyp.purchase,
				:orno, :pono, :sqnb, :rcno, :rseq}
		 and	tfacp251._compnr = :tfgld106.ocmp
		as set with 1 rows
		selectdo
			select	whinh312.item:twsap116.item,
				whinh312.rcun:twsap116.cuni
			from	whinh312
			where	whinh312._compnr = {:tmp.loco}
			  and 	whinh312._index1 = {:rcno, :rseq}
			  and	whinh312.psno = :tmp.shpm
			as set with 1 rows
			selectdo
				select	tcibd001.cuni:twsap116.cuni
				from	tcibd001
				where	tcibd001._index1 = {:twsap116.item}
				as set with 1 rows
				selectdo
				endselect
			selectempty
				select	whinh431.item:twsap116.item,
					whinh431.cuni:twsap116.cuni
				from	whinh431
				where	whinh431._index1 = {:rcno, :rseq}
				and	whinh431.worg = whinh.oorg.purchase
				and	whinh431.worn = :orno
				and	whinh431.wpon = :pono
				and	whinh431.wseq = :sqnb
				and	whinh431._compnr = :tmp.loco
				as set with 1 rows
				selectdo
				endselect
			endselect

			if not isspace(twsap116.item) then
				twsap116.orno = orno
				twsap116.pono = pono
				twsap116.sqnb = sqnb
				twsap116.rcno = rcno
				twsap116.rseq = rseq
			endif
		endselect
	endif

	|* ana oaaeeou tc ii-oiie?aie? aoaoo niio?aou a 201
	|* iiyoiio ooo eiaenoe?aneea eiiiaiee ia ia?ii eniieuciaaou
	select	tcmcs001.icun:twsap116.icun
	from	tcmcs001
	where	tcmcs001._index1 = {:twsap116.cuni}
	as set with 1 rows
	selectdo
	endselect

	|* Caiieiaiea cia?aiea eiaa eiio?aaaioa ii MDM
	select 	tcyru021.seab.l:twsap116.bmdm
	from	tcyru021
	where	tcyru021._index1 = {:twsap116.bpid}
	as set with 1 rows
	selectdo
	endselect

	|* Caiieiaiea cia?aiea eiaa ecaaeey ii MDM
	select 	tcibd001.seab:twsap116.imdm
	from	tcibd001
	where	tcibd001._index1 = {:twsap116.item}
	as set with 1 rows
	selectdo
	endselect
	
	if not isspace(g.inr.rcno) then 			|#SH-IPLCINT0011-1.sn
		twsap116.sfno = ""
		select 	whinh312.psno:twsap116.sfno
		from	whinh312
		where	whinh312._index1 = {:g.inr.rcno,:g.inr.rcln}
		as set with 1 rows
		selectdo
		endselect
		twsap116.rcno = g.inr.rcno
	endif 
	
	if not isspace(g.inr.shpm) then 
		twsap116.sfno = ""
		nakl.num = ""
		nakl.pdat = 0
		select 	twutl016.nakl:nakl.num,
				twutl016.pdat:nakl.pdat
		from	twutl016,
				twutl017
		where	twutl017.shpm = {:g.inr.shpm}
		  and 	twutl016._index1 = {twutl017.nakl}
		as set with 1 rows
		selectdo
		selectempty 
			select 	whinh430.cdat:nakl.pdat
			from	whinh430
			where	whinh430._index1 = {:g.inr.shpm}
			as set with 1 rows
			selectdo
				nakl.num = g.inr.shpm
			endselect
		endselect
		
		twsap116.rcno = g.inr.shpm
		twsap116.sfno = concat$(" ",
							trim$(nakl.num),
							chr$(222) & chr$(226),
							sprintf$("%u002",nakl.pdat))
	endif									|#SH-IPLCINT0011-1.en
			

	if do.insert then
		|* anoaaea aaiiuo a ?anoe?aiiue aooa?, i?iioneay aoaeeeaou
		|* aoaeeeaou ii?aaaey?ony ii GUID
		twsap116.logn = logname$
		twsap116.uplt = utc.num()
		twsap116.upid = g.upid 
		twsap116.tsys = g.target
		if dll0106.uplt > 0 then
			twsap116.uplt = dll0106.uplt
		endif
		update.queue(twsap116.unid)
		db.insert(ttwsap116, db.retry, db.skip.dupl)
		|* save move to point change dll0106.unid
		|COMMIT.100(i.seqn)
|	else
|		dll0106.data.size = dll0106.data.size + 1
|		alloc.mem(dll0106.data, len(rcd.ttwsap116), dll0106.data.size)
|		dll0106.data(1, dll0106.data.size) = rcd.ttwsap116
	endif
	if print.report then
		|* auaanoe no?ieo a io?ao
		rprt_send()
	endif

	if need.reverse.update then
		reverse.update.for.unid(i.seqn)
	endif
}

function fill.buffer.zero.price(
			ref	domain	tcsern		i.seqn,
						boolean		print.report,
						boolean		do.insert)
{
			String		dummy.str(16)
	domain	tfgld.leac	tmp.default.debit.account
	domain	tfgld.leac	tmp.default.credit.account
	string				tmp.msg
	
	domain	whina.valg	cwar.wvgr
	domain	tccitg		item.citg
			
	
	domain	tcdate		date.posd						|#SH-IPLCINT009-1.sn
			long		dummy.long						|#SH-IPLCINT009-1.en
	
	long	yearno,monthno,month_dayno,hours,minutes,seconds
	
	e = utc.to.date(whinr110.trdt,yearno,monthno,month_dayno,hours,minutes,seconds)
	
	
	i.seqn = i.seqn + 1
	db.set.to.default(ttwsap116)
	twsap116.unid = dll0106.unid
	twsap116.seqn = i.seqn
	twsap116.ocmp = whinr110.ocmp
	twsap116.fyer = yearno
	twsap116.fprd = monthno
	twsap116.cwar = whinr110.cwar
	twsap116.item = whinr110.item
	twsap116.iqan = whinr110.qstk
	twsap116.orno = whinr110.orno
	twsap116.pono = whinr110.pono			
	
	utc.to.local(whinr110.trdt,date.posd, dummy.long) 	|#SH-IPLCINT009-1.sn
	
	if date.posd < 0  then 
		date.posd = 0
	endif	
	twsap116.posd = date.posd							|#SH-IPLCINT009-1.en
	
	twsap116.aufnr = whinr110.orno
	twsap116.idtc = ZERO_PRICE_IDTC	
	
	twsap116.rbon = "whinr110"
	
	string.scan(twsap109.guid,
				"%s/%s/%d",
				dummy.str,
				twsap116.rbid,
				twsap116.rpon)
				
	|* Caiieiaiea cia?aiea eiaa ecaaeey ii MDM
	select 	tcibd001.seab:twsap116.imdm,
			tcibd001.citg:item.citg
	from	tcibd001
	where	tcibd001._index1 = {:twsap116.item}
	as set with 1 rows
	selectdo
	endselect
	
	select 	whwmd200.wvgr:cwar.wvgr
	from	whwmd200	
	where	whwmd200._index1 = {:whinr110.cwar}	
	as set with 1 rows
	selectdo
	endselect
	
	twsap.dll1220.find.active.scheme.leadger.account(
			cwar.wvgr,
			item.citg,
			tmp.default.debit.account,
			tmp.default.credit.account,
			tmp.msg)
	
	twsap116.leac = tmp.default.debit.account		
	
	on case whinr110.kost
	case tckost.stc.correction: twsap116.itpi = "ZERO_PRICE_Cor" 		break
	case tckost.receipt:		twsap116.itpi = "ZERO_PRICE_Receipt" 	break
	case tckost.issue:			twsap116.itpi = "ZERO_PRICE_Issue"		break	
		break
	endcase
	
	if do.insert then
			|* anoaaea aaiiuo a ?anoe?aiiue aooa?, i?iioneay aoaeeeaou
			|* aoaeeeaou ii?aaaey?ony ii GUID
			twsap116.logn = logname$
			twsap116.uplt = utc.num()
			twsap116.upid = g.upid 
			twsap116.tsys = g.target
			if dll0106.uplt > 0 then
				twsap116.uplt = dll0106.uplt
			endif
			g.int.lcmp = twsap116.ocmp
			update.queue(twsap116.unid)
			db.insert(ttwsap116, db.retry, db.skip.dupl)
	endif
	if print.report then
		|* auaanoe no?ieo a io?ao
		rprt_send()
	endif
}

function update.queue(
			domain tcguid	i.unid)
{
	select 	* 
	from	twsap109 for update 
	where 	twsap109._index2 = {
					:twsap116.ocmp,:g.int.lcmp,
					:twsap116.rbon,:twsap116.rbid,
					:twsap116.rpon}
	|where	twsap109.rbon = :twsap116.rbon 
	|  and	twsap109.rbid = :twsap116.rbid
	|  and	twsap109.rpon = :twsap116.rpon
													|#SH-IPLCINT0012-1.so
	|* if skip WH_Transfer issue then after export with receipt
	|* will be update unid number in queue
	|  and	twsap109.proc <> tcyesno.yes			|#SH-IPLCINT0012-1.eo
	selectdo
		twsap109.proc = tcyesno.yes 
		twsap109.unid = i.unid
		e = db.update(ttwsap109,db.retry)
	endselect
	  
}

function reverse.update.for.unid(	domain	tcsern		i.cur.seqn)
{
	domain	tcmcs.str3	cur.cort

	cur.cort = twsap116.cort

	select	twsap116.*
	from	twsap116 for update
	where	twsap116._index1 = {:dll0106.unid}
	and	twsap116.seqn < :i.cur.seqn
	selectdo
		twsap116.cort = cur.cort
		db.update(ttwsap116, db.retry)
	endselect
}

function fill.storage.record.sales.buffer(
				ref	domain	tcsern		i.seqn,
						boolean		do.default,
						boolean		is.approval,
						boolean		print.report,
						boolean		do.insert)
{
	domain	tcorno		orno
	domain	tcpono		pono, sqnb
	domain	whinh.shpm	rcno
	domain	whinh.sern	rseq

	domain	tfgld.docn	dummy.oinv
	domain	tfgld.amnt	inv.amnt

	domain	tcncmp		tmp.loco
	domain	whinh.pksp	tmp.shpm

	domain	tcdate		tmp.posd
	domain	tcmcs.long	tmp.time

	domain	cisli.srtp	tmp.srtp
	domain	cisli.tref	tmp.tref
	domain	tcpono		tmp.sqnb

		boolean		repeated.export, is.storno,
				need.reverse.update
		String		dummy.str

	domain	tfacp.isup 	tmp.sfno
	domain	tfgld.date	tmp.sfdt
	domain	tfacp.inv	tmp.appr
	domain	tfyru.invf.l	tmp.invf
	domain	tfgld.docn	tmp.oinv
	domain	tfgld.amnt	tmp.amti
	domain	tcpono		tmp.adjn
	domain	tfgld.date	tmp.rcpd

	need.reverse.update = false
	|i.seqn = i.seqn + 1

	|* i?enoea cia?aiee iieae
	if do.default then
		db.set.to.default(ttwsap116)
	endif

	|* caienuaaai ana oieuei a oeiainiaua eiiiaiee
	|twsap116._compnr = tfgld106.ocmp

	twsap116.unid = dll0106.unid
	|twsap116.seqn = i.seqn
	twsap116.ocmp = tfgld106.ocmp
	twsap116.fyer = tfgld106.fyer
	twsap116.fprd = tfgld106.fprd
	twsap116.otyp = tfgld106.otyp
	twsap116.odoc = tfgld106.odoc
|	twsap116.olin = tfgld106.olin
	twsap116.osrl = tfgld106.osrl
	twsap116.osrn = tfgld106.osrn
	twsap116.dcdt = tfgld106.dcdt
|	twsap116.date = tfgld106.date
|	twsap116.ratd = tfgld106.ratd
|	twsap116.rate = tfgld106.rate
|	twsap116.ratf = tfgld106.fact
	twsap116.rtyp = tfgld106.rtyp
	twsap116.leac = tfgld106.leac
	twsap116.dbcr = tfgld106.dbcr
	twsap116.ccur = tfgld106.ccur
	twsap116.vcur = virtual.currency(twsap116.ccur)
|	twsap116.amnt = tfgld106.amnt
|	twsap116.amth = tfgld106.amth
	twsap116.bpid = tfgld106.bpid
	if not control.account(SALES.INVOICING,twsap116.leac) then
		twsap116.bpid = ""
	endif
|	twsap116.ctyp = tfgld106.ctyp
|	twsap116.cinv = tfgld106.cinv
	twsap116.crus = tfgld106.user
	twsap116.cont = tfgld106.cont

	twsap116.cfod = tfgld106.dim1
	twsap116.cpcp = tfgld106.dim3


	read.invoice.data(	true,
				tfgld106.otyp,
				tfgld106.odoc,
				twsap116.fyer,
				twsap116.fprd,
|				tmp.sfno, 	|* ref
|				tmp.sfdt, 	|* ref
				twsap116.sfno,
				twsap116.sfdt,
				tmp.appr, 	|* ref
				tmp.invf,	|* ref
				tmp.oinv,	|* ref
|				tmp.amti,	|* ref
				inv.amnt,
				tmp.adjn,	|* ref
				tmp.rcpd,	|* ref
				twsap116.posd) |* ref

	|* ii?aaaeaiea oeia NO e aaiiuo i?eae?aeuiiai NO
	read.sales.invoice.data(
					tfgld106.ocmp,
					tfgld106.otyp,
					tfgld106.odoc,
					twsap116.ctyp,
					twsap116.cinv,
					twsap116.invfl,
					twsap116.adjn)
	if isspace(twsap116.ctyp) then
		twsap116.ctyp = tfgld106.ctyp
		twsap116.cinv = tfgld106.cinv
	endif


	|* oieuei aey NO
|	if twsap116.odoc_st <> 0 then
|		twsap116.itpi = "INP_MAT_REV"
|	else
|		on case twsap116.invfl
|		case tfyru.invf.l.original:
|			twsap116.itpi =  "INP_MAT_IINV"
|			break
|		case tfyru.invf.l.correction:
|			twsap116.itpi =  "INP_MAT_CORR"
|			break
|		case tfyru.invf.l.orig.adjust:
|			twsap116.itpi =  "INP_MAT_ISPR"
|			break
|		case tfyru.invf.l.corr.adjust:
|			twsap116.itpi =  "INP_MAT_ISPR"
|			break
|		endcase
|	endif

|	if sales.invoice.is.storno(
|			tfgld106.ocmp,
|			tfgld106.otyp,
|			tfgld106.odoc)
|	then
|		twsap116.itpi = "INR_INV_MAT_ST"
|	else
|		twsap116.itpi = "INR_INV_MAT"
|	endif
|	twsap116.itpi = g.int.itpi
|	twsap116.posd = g.int.posd

	|* Caienuaaai aaiiua i?eaeiaeuiiai NO aey ei??aeoe?iai?iuo
	|twsap116.fyer_or = g.fyer_or
	|twsap116.fprd_or = g.fprd_or
	|twsap116.otyp_or = g.otyp_or
	|twsap116.odoc_or = g.odoc_or

	|* Anee ei??aeoe?iaea, oi ii?aaaeyai ciae ei??aeoe?iaee
	if twsap116.invfl <> tfyru.invf.l.original then
		if not isspace(g.cort) then
			twsap116.cort = g.cort
		else
			|* ii-oiie?aie? i?enaaeaaai oei = ei?? No ia oaaee?aiea
			twsap116.cort = "INC"
			if LESS.THAN.ZERO(inv.amnt) and not isspace(twsap116.bpid) then
				|* anee iaiuoa ioey, oi ei??.NO ia oiaiuoaiea
				twsap116.cort = "DEC"
				g.cort = twsap116.cort
				need.reverse.update = true
			endif
		endif
	endif


	|* Caiieiaiea cia?aiea eiaa eiio?aaaioa ii MDM
	select 	tcyru021.seab.l:twsap116.bmdm
	from	tcyru021
	where	tcyru021._index1 = {:twsap116.bpid}
	as set with 1 rows
	selectdo
	endselect

	|read.cisli310()
	select 	cisli310.line:twsap116.olin,
			cisli310.ddat:tmp.posd, |DDAT as POSTING_DATE,
			|cisli310.ddat:tfgld106.ddat, |DDAT as "DATE",
			cisli310.ratd:twsap116.ratd, |RATD as RATD,
			cisli310.rate:twsap116.rate, |RATE$1 as RATE,
			cisli310.ratf:twsap116.ratf,
			cisli310.rtyp:twsap116.rtyp, |RTYP as RTYP,
			cisli310.item:twsap116.item,			|twsap116.orno = orno
			cisli310.orno:twsap116.orno,               |twsap116.pono = pono
			cisli310.pono:twsap116.pono,               |twsap116.sqnb = sqnb
			cisli310.shpm:twsap116.rcno,               |twsap116.rcno = rcno
			cisli310.shln:twsap116.rseq,               |twsap116.rseq = rseq
|			cisli310.cvat:tfgld106.cvat,
			cisli310.cvat:twsap116.cvat,
			cisli310.amti:twsap116.amnt,
			cisli310.amth:twsap116.amth,
			cisli310.tbai:twsap116.vtba,			| as VATB_AMNT,
			cisli310.tbah:twsap116.vtbh,
			cisli310.srtp:tmp.srtp,
			cisli310.tref:tmp.tref
	from 	cisli310
	where	cisli310._index1 = {:twsap116.ocmp,:twsap116.otyp,:twsap116.odoc}
	and	cisli310.cvat = :tfgld106.cvat
	selectdo

		i.seqn = i.seqn + 1
		twsap116.seqn = i.seqn

		|* Caiieiaiea cia?aiea eiaa ecaaeey ii MDM
		select 	tcibd001.seab:twsap116.imdm
		from	tcibd001
		where	tcibd001._index1 = {:twsap116.item}
		as set with 1 rows
		selectdo
		endselect

		twsap116.iqan = 0.0
		twsap116.cuni = ""
		is.storno = false
		select	whinh431.qshp:twsap116.iqan,
			whinh431.cuni:twsap116.cuni
		from	whinh431
		where	whinh431._index1 = {:twsap116.rcno, :twsap116.rseq}
		as set with 1 rows
		selectdo
		selectempty
			|* since there's no distinct criteria to determine
			|* whether this is is a direct or storno sales,
			|* the sequential check in both shipments and
			|* recipts is the only way to get relevant data

			select	whinh312.qrcr:twsap116.iqan,
				whinh312.rcun:twsap116.cuni
			from	whinh312
			where	whinh312._index1 = {:twsap116.rcno, :twsap116.rseq}
			as set with 1 rows
			selectdo
				is.storno = true
			endselect
		endselect

|		if tmp.srtp = cisli.srtp.wareh.order then
|			on case twsap116.invfl
|			case tfyru.invf.l.original:
|				twsap116.itpi = "INR_INV_MOV_ST"
|				break
|			case tfyru.invf.l.correction:
|				twsap116.itpi = "INR_INV_COR"
|				break
|			case tfyru.invf.l.orig.adjust:
|				twsap116.itpi = "INR_INV_ISPR"
|				break
|			endcase
|		endif

		on case twsap116.invfl
		case tfyru.invf.l.original:
			if	tmp.srtp = cisli.srtp.sales.order and
|			if	is.storno and tmp.srtp = cisli.srtp.sales.order and
				string.scan(tmp.tref, "%s|%s|%d",
					dummy.str, dummy.str, tmp.sqnb) >= 3
			then
				select	tdsls401.ttyp:twsap116.otyp_st,
					tdsls401.invn:twsap116.odoc_st,
					tfgld100.year:twsap116.fyer_st,
					tfgld100.fprd:twsap116.fprd_st
				from	tdsls402, tdsls401, tfgld018, tfgld100
				where	tdsls402._index1 = {:twsap116.orno,
						:twsap116.pono, :tmp.sqnb}
				and	tdsls401._index1 = {tdsls402.reto,
						tdsls402.retp, tdsls402.rets}
				and	tfgld018._index1 = {tdsls401.ttyp,
						tdsls401.invn}
				and	tfgld100._index1 = {tfgld018.year,
						tfgld018.btno}
				as set with 1 rows
				selectdo
				endselect
			endif
			break
		case tfyru.invf.l.correction:
		case tfyru.invf.l.orig.adjust:
|			twsap116.itpi = twsap116.invfl = tfyru.invf.l.correction ?
|						"INR_INV_COR" : "INR_INV_ISPR"
			select	ciyru022.ltyp.l:twsap116.otyp_or,
				ciyru022.linv.l:twsap116.odoc_or,
				tfgld100.year:twsap116.fyer_or,
				tfgld100.fprd:twsap116.fprd_or
			from	ciyru022, tfgld018, tfgld100
			where	ciyru022._index1 = {:twsap116.ocmp,
					:twsap116.otyp, :twsap116.odoc}
			and	tfgld018._index1 = {ciyru022.ltyp.l,
					ciyru022.linv.l}
			and	tfgld100._index1 = {tfgld018.year, tfgld018.btno}
			as set with 1 rows
			selectdo
			endselect
			break
		endcase

		update.integr.proc.id()

		select	tcmcs001.icun:twsap116.icun
		from	tcmcs001
		where	tcmcs001._index1 = {:twsap116.cuni}
		as set with 1 rows
		selectdo
		endselect

|		e = utc.to.local(tmp.posd,twsap116.posd,tmp.time)

		update.amount.signs(	twsap116.amnt, twsap116.amth,
					twsap116.vtba, twsap116.vtbh)

		if do.insert then
			|* anoaaea aaiiuo a ?anoe?aiiue aooa?, i?iioneay aoaeeeaou
			|* aoaeeeaou ii?aaaey?ony ii GUID
			twsap116.logn = logname$
			twsap116.uplt = utc.num()
			if dll0106.uplt > 0 then
				twsap116.uplt = dll0106.uplt
			endif
			db.insert(ttwsap116, db.retry, db.skip.dupl)
			COMMIT.100(i.seqn)
	|	else
	|		dll0106.data.size = dll0106.data.size + 1
	|		alloc.mem(dll0106.data, len(rcd.ttwsap116), dll0106.data.size)
	|		dll0106.data(1, dll0106.data.size) = rcd.ttwsap116
		endif
		if print.report then
			|* auaanoe no?ieo a io?ao
			rprt_send()
		endif

	endselect

	if need.reverse.update then
		reverse.update.for.unid(i.seqn)
	endif
}


function long read.warehouse.order(
						domain	tckoor 	i.koor,
						domain	tckost 	i.kost,
						domain	tcorno	i.orno,
						domain	tcpono	i.pono,
					ref	domain	tctyps	o.sfty,
					ref domain 	tctyps	o.stty,
					ref	domain	tccwar	o.sfco,
					ref	domain	tccwar	o.stco,
					ref	domain	tccwoc	o.cwoc,
					ref	domain	tccwoc	o.wdep)

{
		domain	tcwset		orno.oset

		o.sfco = ""
		o.stco = ""
		o.sfty = tctyps.not.appl
		o.stty = tctyps.not.appl
		o.cwoc = ""
		orno.oset = 1

		|* ii?aaaeyai iaai? caeaca ii no?iea caeaca, eioi?ay oieeaeuia
		|* a ?aieao iaiiai caeaca e ?aciuo iaai?ia yoiai caeaca
		if i.kost = tckost.receipt then
			select 	whinh210.oset:orno.oset
			from	whinh210
			where	whinh210._index1 = {:1, :i.orno, :i.pono}
			as set with 1 rows
			wherebind (1, whinh.dll0000.convert.koor.to.oorg(i.koor))
			selectdo
			endselect
		else
			select 	whinh220.oset:orno.oset
			from	whinh220
			where	whinh220._index1 = {:1, :i.orno, :i.pono}
			as set with 1 rows
			wherebind (1, whinh.dll0000.convert.koor.to.oorg(i.koor))
			selectdo
			endselect
		endif

		select	whinh200.sfty:o.sfty,
				whinh200.stty:o.stty,
				whinh200.sfco:o.sfco,
				whinh200.stco:o.stco,
				whinh200.cwoc:o.cwoc,
				whinh200.wdep:o.wdep
		from	whinh200
		where	whinh200._index1 = {:1, :i.orno,:orno.oset}
		as set with 1 rows
		wherebind (1, whinh.dll0000.convert.koor.to.oorg(i.koor))
		selectdo
			return(true)
		endselect

		return(false)
}

function long read.pur.order(
						domain	tcorno	i.orno,
					ref	domain	tccotp	o.otyp)

{
		domain	tcwset		orno.oset

		select	tdpur400.cotp:o.otyp
		from	tdpur400
		where	tdpur400._index1 = {:i.orno}
		as set with 1 rows
		selectdo
			return(true)
		endselect

		return(false)
}

|#SH-IPLCINT0014-1.sn
function long read.pur.subc(
						domain	tcorno	i.orno,
						domain	tcpono	i.pono,
					ref	domain	tcyesno	o.subc)

{

		select	tdpur401.subc:o.subc
		from	tdpur401,
				tdpur400
		where	tdpur401._index1 = {:i.orno,:i.pono}
		  and 	tdpur400._index1 = tdpur401._index1
		  and	tdpur400.cotp in ('OUT','SBD','PU4','PRS')
		as set with 1 rows
		selectdo
			return(true)
		endselect

		return(false)
}
|#SH-IPLCINT0014-1.en

function long control.account(
			domain	tcmcs.str13		i.process.code,
			domain	tfgld.leac		i.leac)
{
	domain	tfgld.leac	tmp.leac

	on case i.process.code
	case "twsap1206m000":
		select 	tfacp015.leac:tmp.leac
		from	tfacp015
		where	tfacp015._index2 = {:i.leac}
		as set with 1 rows
		selectdo
			return(true)
		endselect
		break
	case "twsap1206m400":
		select 	tfacr015.leac:tmp.leac
		from	tfacr015
		where	tfacr015.leac = :i.leac
		as set with 1 rows
		selectdo
			return(true)
		endselect
		break
	endcase


	return(false)
}

function long record.exist.twsap116()
{
	|* i?aaiieaaaai, ?oi anee iu na?ineee i?a?aau, oi iu oaeaiai?aaeaii
	|* iaia?aiu iiaoi?ii aua?oceou aaiiua a aooa?
	return(false)


	|* i?iaa?ea nouanoaiaaiey caiene a ?anoe?aiiii aooa?a
	|* oieuei aey iia?aoee eioaa?aoee
	domain	tcguid  tmp.unid
	|* check records only for integration records
	if isspace(g.int.idtc) then
		return(true)
	endif

	select 	twsap116.unid:tmp.unid
	from	twsap116
	where	twsap116.odoc = :tfgld106.odoc
	and	twsap116.olin = :tfgld106.olin
	  and 	twsap116.rbon = :g.int.rbon
	  and 	twsap116.rbid = :g.int.rbid
	  and 	twsap116.rpon = :g.int.rpon
	  and 	twsap116.dbcr = :tfgld106.dbcr
	as set with 1 rows
	selectdo
		dll.count.skip.dupl = dll.count.skip.dupl + 1
		return(true)
	endselect

	return(false)
}

|function extern domain	tcbool twsap.dll0116.type.to.sap(
|					domain	tfgld.ttyp	i.ttyp)
|{
|	DLLUSAGE
|		|* ooeioey i?iaa?yao, i?enoonoaea oeia iia?aoee a oaaeeoa iano?ieee
|		|* oeiia aey aua?ocee a SAP
|		|* save.ret
|		|*	- true, oei iia?aoee iaeaai a iano?ieeao twsap0510m000
|		|*	- false, oei iia?aoee iaeaai a iano?ieeao twsap0510m000
|	ENDDLLUSAGE
|
|		static	domain	tcbool		save.ret
|		static	domain	tfgld.ttyp	save.ttyp
|
|		if save.ttyp = i.ttyp then
|			return(save.ret)
|		endif
|
|		save.ttyp = ""
|		save.ret = false
|
|		select	twsap010.ttyp:save.ttyp
|		from	twsap010
|		where	twsap010._index1 = {:i.ttyp}
|		as set with 1 rows
|		selectdo
|			save.ret = true
|		endselect
|
|		return(save.ret)
|}

|function long read.type.setting(
|					domain	tfgld.ttyp		i.ttyp,
|			ref		domain	tcmcs.str10		o.catg,
|			ref		domain	tcmcs.str10		o.proc,
|			ref		domain	tcmcs.str10		o.prct)
|{
|		|* ooeioey iano?ieee aey oeia iia?aoee
|		|* save.ret
|		|*	- true, oei iia?aoee iaeaai a iano?ieeao twsap0510m000
|		|*	- false, oei iia?aoee iaeaai a iano?ieeao twsap0510m000
|		|* o.catg, aica?auaao eaoaai?ey iia?aoee ec twsap010
|		|* o.proc, aica?auaao oei i?ioanna ec twsap010
|		|* o.prcv, aica?auaao aea i?ioanna twsap010
|
|		static	domain	tcbool			save.ret
|		static	domain	tfgld.ttyp		save.ttyp
|		static	domain	tcmcs.str10		save.catg
|		static	domain	tcmcs.str10		save.proc
|		static	domain	tcmcs.str10		save.prct
|
|
|		|* ia ia?a?eouaaou iano?ieee, anee caoee aoi?ie ?ac n oai ?a aieoiaioii
|		if save.ttyp = i.ttyp then
|			o.catg = save.catg
|			o.proc = save.proc
|			o.prct = save.prct
|			return(save.ret)
|		endif
|
|		save.ttyp = i.ttyp
|		save.ret = false
|
|		select	twsap010.catg:save.catg,
|				twsap010.proc:save.proc,
|				twsap010.prct:save.prct
|		from	twsap010
|		where	twsap010._index1 = {:i.ttyp}
|		as set with 1 rows
|		selectdo
|			save.ret = true
|		endselect
|
|		o.catg = save.catg
|		o.proc = save.proc
|		o.prct = save.prct
|
|		return(save.ret)
|}

function long read.document.is.storno()
{
		|* euai a oaeouai aieoiaioa ooaa??aaiey eiio?ieuiue n?ao
		|* a aaiiuo tfacp005 - N?aoa aeaaiie eieae ii a?oiia iinoaaueeia
		|* n i?eciaeii tfacp.tran.inv.receipts - Iinooieaiey ii NO


		domain 	tcbool		save.ret
		domain	tfgld.leac	tmp.leac

		save.ret = false

		select 	tfgld106.leac:tmp.leac
		from	tfgld106,
				tfacp005
		where	tfgld106._index1 = {:tfgld106.otyp,:tfgld106.odoc}
		  and 	tfgld106.dbcr = tfgld.dbcr.debit
		  and 	tfacp005._index2 = tfgld106.leac
		  |* tfacp.tran.inv.receipts - Iinooieaiey ii NO
		  and  	tfacp005.tran = tfacp.tran.inv.receipts
		  and	tfgld106._compnr = :tfgld106.ocmp
		  and	tfacp005._compnr = :tfgld106.ocmp
		as set with 1 rows
		selectdo
			save.ret = true
		endselect

		return(save.ret)
}

function long read.storno.document.data()
{
		|* ?oaiea aaiiuo aey noi?ie?oaiie no?iee.
		domain 	tcbool			save.ret
		domain	tfacp.inv		dummy.appr
		domain	tfyru.invf.l	dummy.invf
		domain	tcpono			dummy.adjn
		domain	tfgld.date		dummy.rcpd
		domain	tfgld.docn		dummy.oinv
		domain	tfgld.amnt		dummy.amnt

		save.ret = false


		|* euai aee?aeoee ii iiia?o "odoc" aieoiaio n oai ?a oeiii "otyp"
		|* aey eioi?iai yoi noi?ii.
		select 	tfgld106.fyer:g.fyer_st,
				tfgld106.fprd:g.fprd_st,
				tfgld106.otyp:g.otyp_st,
				tfgld106.odoc:g.odoc_st
		from	tfgld106
		where	tfgld106._index9 = {:tfgld106.ctyp,:tfgld106.cinv,:tfgld106.otyp}
		  and	tfgld106.odoc < :tfgld106.odoc
		  and	tfgld106._compnr = :tfgld106.ocmp
		order by tfgld106.odoc desc
		as set with 1 rows
		selectdo
			save.ret = true
		selectempty
			save.ret = false
			return(save.ret)
		endselect

		|* ?oaiea aaiiuo ec i?eaeiaeuiie NO
		read.invoice.data(
					false,		|is.approval,
					g.otyp_st,
					g.odoc_st,
					g.fyer_st,
					g.fprd_st,
					g.sfno_st, 	|* ref
					g.sfdt_st, 	|* ref
					dummy.appr, |* ref
					dummy.invf, |* ref
					dummy.oinv,	|* ref
					dummy.amnt, |* ref
					dummy.adjn, |* ref
					|dummy.oinv,|* ref
					dummy.rcpd, |* ref
					g.posd_st) 	|* ref

		return(save.ret)
}


function read.invoice.data(
				boolean			is.approval,
			domain	tfgld.ttyp		i.ttyp,
			domain	tfgld.docn		i.docn,
			domain	tfgld.year		i.fyer,
			domain	tfgld.prod		i.fprd,
		ref	domain	tfacp.isup 		o.sfno,
		ref	domain	tfgld.date		o.sfdt,
		ref	domain	tfacp.inv		o.appr,
		ref	domain	tfyru.invf.l		o.invf,
		ref	domain	tfgld.docn		o.oinv,
		ref 	domain	tfgld.amnt		o.amti,
		ref	domain	tcpono			o.adjn,
		ref	domain	tfgld.date		o.rcpd,
		ref	domain	tfgld.date		o.posd)
{
	long		dcdt.year, dcdt.peri, dcdt.dayn
	long 		ret.acp200.selected

	| iiia? ei??aeoe?oaiie NO

	if not is.approval then
		|* ?eoaai oieuei aey NO, aey ooaa??aaiey oieuei caienuaaai oi
		|* ?oi i?i?eoaee
		|* iu aie?iu iaoiaeony a oaeouae oeiainiaie eiiiaiee
		|* iiyoiio ooo anaaaa aoaao niio?aou a io?io? oei. eiiiaie?
		ret.acp200.selected = false
		select	tfacp100.isup:g.inv.sfno,
				tfacp100.invd:g.inv.sfdt,
				tfacp100.amti:g.inv.amti,
				tfyru021.invf.l:g.inv.invf,
				tfyru021.adjn.l:g.inv.adjn,
				tfyru021.oinv.l:g.inv.oinv,
				tfyru021.rcpd.l:g.inv.rcpd
		from	tfacp100,tfyru021
		where	tfacp100._index4 = {:i.ttyp, :i.docn}
		  and	tfacp100._compnr = :tfgld106.ocmp
		  and 	tfyru021._index1 refers to tfacp100 unref clearunref
		as set with 1 rows
		selectdo
		selectempty
			select	tfacp200.isup:g.inv.sfno,
					tfacp200.docd:g.inv.sfdt,
					tfacp200.appr:g.inv.appr
			from	tfacp200
			where	tfacp200._index1 = {:i.ttyp, :i.docn, 0}
			  and	tfacp200._compnr = :tfgld106.ocmp
			as set with 1 rows
			selectdo
				ret.acp200.selected = true
			endselect
		endselect

		if not ret.acp200.selected then
			select	tfacp200.appr:g.inv.appr
			from	tfacp200
			where	tfacp200._index1 = {:i.ttyp, :i.docn, 0}
			  and	tfacp200._compnr = :tfgld106.ocmp
			as set with 1 rows
			selectdo
			endselect
		endif

	endif

	o.appr = g.inv.appr
	o.invf = g.inv.invf
	o.oinv = g.inv.oinv
	o.amti = g.inv.amti
	o.adjn = g.inv.adjn
	o.rcpd = g.inv.rcpd
	o.sfno = g.inv.sfno
	o.sfdt = g.inv.sfdt



	|e = num.to.date(twsap116.dcdt, dcdt.year, dcdt.peri, dcdt.dayn)
	e = num.to.date(o.sfdt, dcdt.year, dcdt.peri, dcdt.dayn)
	if (dcdt.year <> i.fyer or dcdt.peri <> i.fprd) then
		dcdt.year = i.fyer
		dcdt.peri = i.fprd
		dcdt.dayn = 1
	endif
	o.posd = date.to.num(dcdt.year, dcdt.peri, dcdt.dayn)

	if twsap.dll0116.document.is.sales.invoice(i.ttyp, i.docn) then
		domain	tfgld.date	tmp.fmdt

		tmp.fmdt = date.to.num(i.fyer, i.fprd, 1)
		o.posd = tmp.fmdt > tfgld106.dcdt ? tmp.fmdt : tfgld106.dcdt
		o.sfno = str$(tfgld106.odoc)
		o.sfdt = tfgld106.dcdt
		o.amti = tfgld106.amth(1)
	endif
}

function domain tcyesno read.leac.exclude()
{
		|* Anee eaeie-ieaoau n?ao a iaiie ec no?ie aieoiaioa
		|* i?enoonoaoao n i?eciaeii "PRD_MIX",
		|* oi ooeioey aica?auaao true

		domain 	tcyesno		save.ret
		domain	tfgld.ttyp	save.otyp
		domain	tfgld.docn	save.odoc
		domain	tfgld.leac	tmp.leac

		|* anee aoi?ie ?ac caoiaei n iaiei e oai ?a aieoiaioii,
		|* oi iiaoi?ii ia auiieiyai i?iaa?eo, a aica?auaai i?ioue ?acoeuoao,
		|* aey onei?aiey

		if trim$(save.otyp) = trim$(tfgld106.otyp) and
		   save.odoc = tfgld106.odoc
		then
			return(save.ret)
		endif

		save.otyp = tfgld106.otyp
		save.odoc = tfgld106.odoc
		save.ret = tcyesno.no

		select 	tfgld106.leac:tmp.leac
		from	tfgld106,
				twsap011
		where	tfgld106._index1 = {:tfgld106.otyp,:tfgld106.odoc}
		  and 	tfgld106.dbcr = tfgld.dbcr.debit
		  and 	twsap011._index1 = tfgld106.leac
		  and  	twsap011.excl = "PRD_MIX"
		as set with 1 rows
		selectdo
			save.ret = tcyesno.yes
		endselect

		return(save.ret)
}


function domain tcyesno virtual.currency(
				domain	tcccur	i.ccur)
{
	|* I?iaa?ea ia ae?ooaeuiinou aae?ou
	|* ?acoeuo:
	|* tcyesno.yes(1) - Anee aae?oa ae?ooaeuiay
	|* tcyesno.no(2)  - Anee iao

	static	domain	tcyesno save.ret
	static	domain	tcccur	save.ccur
			domain	tcccur	dummy.ccur


	|* ?oiau ia i?iaa?you ianeieuei ?ac iaio e oo?a aae?oo,
	|* aica?auaai ?acoeuoao i?ioeie i?iaa?ee
	if save.ccur = i.ccur then
		return(save.ret)
	endif

	save.ccur = i.ccur
	save.ret  = tcyesno.no

	|* Anee aae?oa ia ?eiaaoi ia "Y"
	if i.ccur(1;1) = "Y" then
		select 	tcmcs002.ccur:dummy.ccur
		from	tcmcs002
		where	tcmcs002._index1 = {:i.ccur}
		  and 	tcmcs002.ccur <> tcmcs002.dscb
		as set with 1 rows
		selectdo
			save.ret = tcyesno.yes
		endselect
	endif

	return(save.ret)

}

function long read.invoice.form()
{
		domain	tfgld.ttyp		inv.cur.type
		domain	tfgld.docn		inv.cur.docn
|		domain	tfgld.docn		inv.cur.ninv
		domain	tfyru.invf.l	inv.cur.invf
		domain	tcpono			inv.cur.adjn
		domain	tfgld.amnt		inv.cur.amti
		domain	tfgld.date		inv.cur.rcpd
		domain	tfgld.date		inv.cur.sfdt
		domain	tfacp.isup 		inv.cur.sfno

|		domain	tfgld.ttyp		inv.orig.type
|		domain	tfgld.docn		inv.orig.docn
		domain	tfgld.docn		inv.orig.ninv
		domain	tfyru.invf.l		inv.orig.invf
		domain	tcpono			inv.orig.adjn
		domain	tfgld.amnt		inv.orig.amti
		domain	tfgld.date		inv.orig.rcpd
		domain	tfgld.date		inv.orig.sfdt
		domain	tfacp.isup 		inv.orig.sfno

		|* ?oaiea aaiiuo ec oaeouae NO
		read.register.invoice.data(
					0,
					tfgld106.ctyp,
					tfgld106.cinv,
					inv.cur.type,
					inv.cur.docn,
					inv.orig.ninv,
					inv.cur.invf,
					inv.cur.adjn,
					inv.cur.amti,
					inv.cur.rcpd,
					inv.cur.sfdt,
					inv.cur.sfno) 	|* ref

		if inv.cur.invf <> tfyru.invf.l.original then
			|* ?oaiea aaiiuo i?eaeiaeuiuo NO
			read.register.invoice.data(
					inv.orig.ninv,
					"",
					0,
					g.otyp_or,
					g.odoc_or,
					inv.orig.ninv,
					inv.orig.invf,
					inv.orig.adjn,
					inv.orig.amti,
					inv.orig.rcpd,
					inv.orig.sfdt,
					inv.orig.sfno)

			select 	tfgld106.fyer:g.fyer_or,
					tfgld106.fprd:g.fprd_or
			from	tfgld106
			where	tfgld106._index1 = {:g.otyp_or,:g.odoc_or}
			as set with 1 rows
			selectdo
			endselect
		endif

		return(false)
}

function long read.register.invoice.data(
				domain	tfgld.docn		i.ninv,
				domain	tfgld.ttyp		i.type,
				domain	tfgld.docn		i.docn,
			ref	domain	tfgld.ttyp		o.type,
			ref	domain	tfgld.docn		o.docn,
			ref	domain	tfgld.docn		o.orig.ninv,
			ref	domain	tfyru.invf.l	o.invf,
			ref	domain	tcpono			o.adjn,
			ref	domain	tfgld.amnt		o.amti,
			ref	domain	tfgld.date		o.rcpd,
			ref	domain	tfgld.date		o.sfdt,
			ref	domain	tfacp.isup 		o.sfno)
{
		o.type = ""
		o.docn = 0
		o.orig.ninv = 0
		o.invf = tfyru.invf.l.original
		o.adjn = 0
		o.amti = 0.0
		o.rcpd = 0
		o.sfdt = 0
		o.sfno = ""

		if not isspace(i.type) and i.docn <> 0 then
			select	tfacp100.invd:o.sfdt,
					tfacp100.isup:o.sfno,
					tfacp100.ctyp:o.type,
					tfacp100.cinv:o.docn,
					tfacp100.amti:o.amti,
					tfyru021.invf.l:o.invf,
					tfyru021.adjn.l:o.adjn,
					tfyru021.oinv.l:o.orig.ninv,
					tfyru021.rcpd.l:o.rcpd
			from	tfacp100,tfyru021
			where	tfacp100._index4 = {:i.type, :i.docn}
			  and	tfacp100._compnr = :tfgld106.ocmp
			  and 	tfyru021._index1 refers to tfacp100 unref clearunref
			as set with 1 rows
			selectdo
			endselect
		else
			select	tfacp100.invd:o.sfdt,
					tfacp100.isup:o.sfno,
					tfacp100.ctyp:o.type,
					tfacp100.cinv:o.docn,
					tfacp100.amti:o.amti,
					tfyru021.invf.l:o.invf,
					tfyru021.adjn.l:o.adjn,
					tfyru021.oinv.l:o.orig.ninv,
					tfyru021.rcpd.l:o.rcpd
			from	tfacp100,tfyru021
			where	tfacp100._index1 = {:i.ninv}
			  and	tfacp100._compnr = :tfgld106.ocmp
			  and 	tfyru021._index1 refers to tfacp100 unref clearunref
			as set with 1 rows
			selectdo
			endselect
		endif

		return(true)
}

|****************************** sales invoice **********************************
function long twsap.dll0116.document.is.sales.invoice(
				domain	tfgld.ttyp		i.type,
				domain	tfgld.docn		i.docn,
			[ref	domain	tcorno			o.brtp])
{
	static	domain	tfgld.ttyp	prev.ttyp
	static	domain	tfgld.docn	prev.docn
	static	domain	cisli.brtp	prev.brtp
	static		boolean		prev.flag

	if i.type <> prev.ttyp or i.docn <> prev.docn then
		prev.flag = false
		select 	cisli200.brtp:prev.brtp
		from	cisli200, cisli305, tfgld011
		where	cisli305._index1 = {:1,:i.type,:i.docn}
		  and	cisli200._index1 = {cisli305.sfcp,cisli305.brid}
		  and	tfgld011._index1 = {cisli305.tran}
		  and 	tfgld011.catg in (3,4,5)
		  |and	cisli200._compnr = i.fcmp
		  |and	cisli200._compnr = i.fcmp
		as set with 1 rows
		wherebind (1,get.compnr())
		selectdo
|			return(twsap.dll0116.check.sales.invoice.type(prev.brtp))
			prev.flag = twsap.dll0116.check.sales.invoice.type(
								prev.brtp)
			prev.ttyp = i.type
			prev.docn = i.docn
		endselect
	endif

	if get.argc() >= 3 then
		e = put.string.arg(3, prev.brtp)
	endif

	return (prev.flag)
|	return(false)
}

function long twsap.dll0116.check.sales.invoice.type(
					domain	tcorno	i.brtp)
{
	on case i.brtp
	|* oaeoo?e?iaaiea i?iaa? OIO
	case "112":
	case "117":
	case "119":	return(true)	break
	|* ia?aiauaiea
	case "115":
	case "118":
	case "120": return(true) 	break
|	case "120": return(false) 	break
	|* oneoaa   |* iiea ia aa?ai
	case "210": return(false) 	break
	endcase

	return(false)
}

function boolean sales.invoice.is.storno(
					domain	tcncmp		i.ocmp,
					domain	tfgld.ttyp	i.ttyp,
					domain	tfgld.docn	i.docn)
{
	static	domain	tcncmp		prv.ocmp
	static	domain	tfgld.ttyp	prv.ttyp
	static	domain	tfgld.docn	prv.docn
	static		boolean		prv.flag

	if (prv.ocmp <> i.ocmp or prv.ttyp <> i.ttyp or prv.docn <> i.docn) then
		prv.ocmp = i.ocmp
		prv.ttyp = i.ttyp
		prv.docn = i.docn

		prv.flag = false
		select 	whinh312.qrcr
		from	cisli310, whinh312
		where	cisli310._index1 = {:prv.ocmp, :prv.ttyp, :prv.docn}
		and	whinh312._index1 = {cisli310.shpm, cisli310.shln}
		as set with 1 rows
		selectdo
			prv.flag = true
		endselect
	endif
	return(prv.flag)
}

function update.integr.proc.id()
{
	domain	tcorno		si.brtp
	domain	tfgld.ttyp	si.ctyp
	domain	tfgld.docn	si.cinv
	domain	tfyru.invf.l	si.invf
	domain	tcpono		si.adjn

	if twsap.dll0116.document.is.sales.invoice(
			tfgld106.otyp, tfgld106.odoc, si.brtp)
	then
		read.sales.invoice.data(
			tfgld106.ocmp, tfgld106.otyp, tfgld106.odoc,
			si.ctyp, si.cinv, si.invf, si.adjn)

		on case si.invf
		case tfyru.invf.l.original:
			on case si.brtp
			case "112":
			case "117":
			case "119":
				if sales.invoice.is.storno(
						tfgld106.ocmp,
						tfgld106.otyp,
						tfgld106.odoc)
				then
					twsap116.itpi = "INR_INV_MAT_ST"
				else
					twsap116.itpi = "INR_INV_MAT"
				endif
				break
			case "115":
			case "118":
			case "120":
				if sales.invoice.is.storno(
						tfgld106.ocmp,
						tfgld106.otyp,
						tfgld106.odoc)
				then
					twsap116.itpi = "INR_INV_MOV_ST"
				else
					twsap116.itpi = "INR_INV_MOV"
				endif
				break
			endcase
			break
		case tfyru.invf.l.correction:
			twsap116.itpi = "INR_INV_COR"
			twsap116.invfl = g.inv.invf
			break
		case tfyru.invf.l.orig.adjust:
			twsap116.itpi = "INR_INV_ISPR"
			twsap116.invfl = g.inv.invf
			break
		endcase
	endif
}

function read.global.sales.invoice.data() {
	static	domain	tcncmp		prev.ocmp
	static	domain	tfgld.ttyp	prev.otyp
	static	domain	tfgld.docn	prev.odoc

		domain	tcorno		tmp.brtp
		domain	tfgld.ttyp	tmp.ctyp
		domain	tfgld.docn	tmp.cinv
		domain	tfyru.invf.l	tmp.invf
		domain	tcpono		tmp.adjn
		domain	cisli.tref	tmp.tref
		domain	tcpono		tmp.sqnb
		domain	tcorno		tmp.orno
		domain	tcpono		tmp.pono
			String		dummy.str

	if	prev.ocmp = tfgld106.ocmp and
		prev.otyp = tfgld106.otyp and
		prev.odoc = tfgld106.odoc
	then
		return
	endif

	prev.ocmp = tfgld106.ocmp
	prev.otyp = tfgld106.otyp
	prev.odoc = tfgld106.odoc

	g.fyer_st = 0
	g.fprd_st = 0
	g.otyp_st = ""
	g.odoc_st = 0
	g.sfno_st = ""
	g.sfdt_st = 0
	g.posd_st = 0

	g.otyp_or = ""
	g.odoc_or = 0
	g.fyer_or = 0
	g.fprd_or = 0

	g.cort = ""

	read.sales.invoice.data(
		tfgld106.ocmp, tfgld106.otyp, tfgld106.odoc,
		tmp.ctyp, tmp.cinv, tmp.invf, tmp.adjn)

	g.inv.invf = tmp.invf
	on case tmp.invf
	case tfyru.invf.l.original:
		select 	cisli310.tref:tmp.tref,
			cisli310.orno:tmp.orno,
			cisli310.pono:tmp.pono
		from 	cisli310
		where	cisli310._index1 = {
				:tfgld106.ocmp,
				:tfgld106.otyp,
				:tfgld106.odoc}
		as set with 1 rows
		selectdo
			if	string.scan(tmp.tref, "%s|%s|%d",
					dummy.str, dummy.str, tmp.sqnb) >= 3
			then
				select	tdsls401.ttyp:g.otyp_st,
					tdsls401.invn:g.odoc_st,
					tfgld100.year:g.fyer_st,
					tfgld100.fprd:g.fprd_st
				from	tdsls402, tdsls401, tfgld018, tfgld100
				where	tdsls402._index1 = {:tmp.orno,
						:tmp.pono, :tmp.sqnb}
				and	tdsls401._index1 = {tdsls402.reto,
						tdsls402.retp, tdsls402.rets}
				and	tfgld018._index1 = {tdsls401.ttyp,
						tdsls401.invn}
				and	tfgld100._index1 = {tfgld018.year,
						tfgld018.btno}
				as set with 1 rows
				selectdo
				endselect
			endif
		endselect
		break
	case tfyru.invf.l.correction:
	case tfyru.invf.l.orig.adjust:
		select	ciyru022.ltyp.l:g.otyp_or,
			ciyru022.linv.l:g.odoc_or,
			tfgld100.year:g.fyer_or,
			tfgld100.fprd:g.fprd_or
		from	ciyru022, tfgld018, tfgld100
		where	ciyru022._index1 = {
				:tfgld106.ocmp,
				:tfgld106.otyp,
				:tfgld106.odoc}
		and	tfgld018._index1 = {
				ciyru022.ltyp.l,
				ciyru022.linv.l}
		and	tfgld100._index1 = {
				tfgld018.year,
				tfgld018.btno}
		as set with 1 rows
		selectdo
		endselect
		break
	endcase
}

function sales.invoice.read.storno.data(
					domain	tcncmp		i.ocmp,
					domain	tfgld.ttyp	i.ttyp,
					domain	tfgld.docn	i.docn,
					domain	tccvat		i.cvat)
{
	static	domain	tcncmp		prv.ocmp
	static	domain	tfgld.ttyp	prv.ttyp
	static	domain	tfgld.docn	prv.docn

		domain	tcorno		tmp.orno
		domain	tcpono		tmp.pono, tmp.sqnb
		domain	cisli.srtp	tmp.srtp
		domain	cisli.tref	tmp.tref
			String		dummy.str

	if (prv.ocmp <> i.ocmp or prv.ttyp <> i.ttyp or prv.docn <> i.docn) then
		prv.ocmp = i.ocmp
		prv.ttyp = i.ttyp
		prv.docn = i.docn

		select 	cisli310.orno:tmp.orno,
			cisli310.pono:tmp.pono,
			cisli310.srtp:tmp.srtp,
			cisli310.tref:tmp.tref
		from 	cisli310
		where	cisli310._index1 = {:i.ocmp, :i.ttyp, :i.docn}
		and	cisli310.cvat = :i.cvat
		selectdo
			if	tmp.srtp = cisli.srtp.sales.order and
|			if	is.storno and tmp.srtp = cisli.srtp.sales.order and
				string.scan(tmp.tref, "%s|%s|%d",
					dummy.str, dummy.str, tmp.sqnb) >= 3
			then
				select	tdsls401.ttyp:twsap116.otyp_st,
					tdsls401.invn:twsap116.odoc_st,
					tfgld100.year:twsap116.fyer_st,
					tfgld100.fprd:twsap116.fprd_st
				from	tdsls402, tdsls401, tfgld018, tfgld100
				where	tdsls402._index1 = {:twsap116.orno,
						:twsap116.pono, :tmp.sqnb}
				and	tdsls401._index1 = {tdsls402.reto,
						tdsls402.retp, tdsls402.rets}
				and	tfgld018._index1 = {tdsls401.ttyp,
						tdsls401.invn}
				and	tfgld100._index1 = {tfgld018.year,
						tfgld018.btno}
				as set with 1 rows
				selectdo
				endselect
			endif
		endselect
	endif
}

function update.amount.signs(		domain	tfgld.amnt	i.amnt,
				ref	domain	tfgld.amnt	i.amth(),
				ref	domain	tfgld.amnt	io.amnt,
				ref	domain	tfgld.amnt	io.amth())
{
	long	ind

	io.amnt = double.cmp(i.amnt, 0.0, 0.0001) * abs(io.amnt)
	for ind = 1 to 3
		io.amth(ind) =
			double.cmp(i.amth(ind), 0.0, 0.0001) *
			abs(io.amth(ind))
	endfor
}

function read.sales.invoice.data(
				domain	tcncmp			i.fcmp,
				domain	tfgld.ttyp		i.otyp,
				domain	tfgld.docn		i.odoc,
			ref	domain	tfgld.ttyp		i.ctyp,
			ref	domain	tfgld.docn		i.cinv,
			ref	domain	tfyru.invf.l		o.invf,
			ref	domain	tcpono			o.adjn)
{
	static	domain	tcncmp		prev.fcmp
	static	domain	tfgld.ttyp	prev.otyp, ret.ctyp
	static	domain	tfgld.docn	prev.odoc, ret.cinv
	static	domain	tfyru.invf.l	ret.invf
	static	domain	tcpono		ret.adjn

	if i.fcmp <> prev.fcmp or i.otyp <> prev.otyp or i.odoc <> prev.odoc then
		prev.fcmp = i.fcmp
		prev.otyp = i.otyp
		prev.odoc = i.odoc
		select 	ciyru022.ltyp.l:ret.ctyp,
			ciyru022.linv.l:ret.cinv,
			ciyru022.invf.l:ret.invf,
			ciyru022.adjn.l:ret.adjn
		from	ciyru022
		where	ciyru022._index1 = {:i.fcmp,:i.otyp,:i.odoc}
		selectdo
		endselect
	endif
	i.ctyp = ret.ctyp
	i.cinv = ret.cinv
	o.invf = ret.invf
	o.adjn = ret.adjn
}

function update.aggregate.ledger.accounts(
					domain	tcncmp			i.fcmp,
					domain	tcncmp			i.lcmp,
					domain	tfgld.ttyp		i.ttyp,
					domain	tfgld.docn		i.docn)
{

	domain	tfgld.leac	cur.leac
		boolean		rec.found
		long		ind, leac.length, dummy.long

	free.mem(g.agr.leac)
	g.agr.leac.len = 0

	e = rdi.domain.string("tfgld.leac", leac.length, dummy.long)

	select	tfgld495.leac:cur.leac
	from	cisli310, tfgld495
	where	cisli310._index1 = {:i.fcmp, :i.ttyp, :i.docn}
	and	tfgld495._index2 = {cisli310.sfcp, tcreco.interim.rev, 5,
			:i.lcmp, cisli310.bona, cisli310.boid}
	and	tfgld495.obre = cisli310.borf
|			:i.lcmp, cisli310.bona, cisli310.boid,
|			cisli310.pono, cisli310.borf}
	selectdo
		rec.found = false
		for ind = 1 to g.agr.leac.len
			if g.agr.leac(1, ind) = cur.leac then
				rec.found = true
				break
			endif
		endfor
		if not rec.found then
			g.agr.leac.len = g.agr.leac.len + 1
			alloc.mem(g.agr.leac, leac.length, g.agr.leac.len)
			g.agr.leac(1, g.agr.leac.len) = cur.leac
		endif
	endselect
}

function boolean ledger.account.is.aggregate(
					domain	tfgld.leac		i.leac)
{
	long	ind

	for ind = 1 to g.agr.leac.len
		if g.agr.leac(1, ind) = i.leac then
			return(true)
		endif
	endfor
	return(false)
}

|function read.cisli310(
|		domain	tcncmp			i.fcmp,
|		domain	tfgld.ttyp		i.otyp,
|		domain	tfgld.docn		i.odoc)
|{
|
|	select 	|cisli310.sfcp:tfgld106.ocmp,
|			|cisli310.tran:tfgld106.otyp,
|			|cisli310.idoc:tfgld106.odoc,
|			cisli310.line:tfgld106.olin,
|			cisli310.ddat:tfgld106.pdat, |DDAT as POSTING_DATE,
|			cisli310.ddat:tfgld106.ddat, |DDAT as "DATE",
|			cisli310.ratd:tfgld106.ratd, |RATD as RATD,
|			cisli310.rate:tfgld106.rate, |RATE$1 as RATE,
|			cisli310.ratf:tfgld106.fact,
|			cisli310.rtyp:tfgld106.rtyp, |RTYP as RTYP,
|			cisli310.item:twsap.item,				|twsap116.orno = orno
|			cisli310.orno:g.inv.orno,               |twsap116.pono = pono
|			cisli310.pono:g.inv.pono,               |twsap116.sqnb = sqnb
|			cisli310.shpm:g.inv.rcno,               |twsap116.rcno = rcno
|			cisli310.shln:g.inv.rseq,               |twsap116.rseq = rseq
|			cisli310.cvat:tfgld106.cvat,
|			cisli310.tbai:tfgld106.vati,			| as VATB_AMNT,
|			cisli310.tbah.1 as VATB_AMTH,
|	from 	cisli310
|	where	cisli310._index1 = {:i.fcmp,:i.otyp,:i.odoc}
|	selectdo
|	endselect
|	|where 	cisli310.sfcp = 201 -- iiia? eiiiaiee
|	|and 	cisli310.tran = 'SL1' -- oei iia?aoee aieoiaioa
|	|and 	cisli310.idoc = '10031556';
|}
|*******************************************************************************

|* koor_kost_1
function extern	long twsap.dll0116.idtc.to.sap(
				domain	tcidty	i.idtc)
{
		|* Anee oae aaeuoa iieaao, oi io?ii aoaao nicaaaaou iano?ia?iue naain
		|* i?iienuaaou oai oeiu eioaa?aoeiiiuo aieoiaioia e i?eaycuaaou eo
		|* e eiao i?ioanna (naaina), eioi?ua aai aoaao ia?aaaouaaou
		i.idtc = trim$(i.idtc)
		on case i.idtc
			case "10014061":	|* I?iecaianoaaiiue caeac/Iia?ao.cao?aou
			case "10037061":	|* Nai?Eeiey/ Iia?aoCo?.
					|* anee aee??aia aua?ocea iia? cao?ao 
					if twsap.dll0000.export.oper.costs.on() then 
						return(true)
					endif
					break
			case "10054013":
			case "10055013":
			case "10060052":	|* WH Issue/Issue
			case "10061074": 	|* WH Receipt/Receipt
			case "10061109":	|* WH Receipt/Value Correction

			case "10061038":
			case "10060031":
			case "10061086":
			case "10061087":
			case "10060054":
			case "10060125":
			case "10060087":
			case "10061088":
			case "10061090":
			case "15060052":
			case "10060117":
			case "10060116":
				|* Anee aee??aia aua?ocea iia?aoee OIO
				if twsap.dll0000.export.oper.tmz.on() then 
					return(true)
				endif
		endcase

		return(false)

}

|* koor_kost_2
function extern domain tcmcs.str256 twsap.dll0116.idtc.query(
					domain	tcbool		i.mode,
					domain	tckoor		i.koor.f,
					domain	tckoor		i.koor.t,
					domain	tckost		i.kost.f,
					domain	tckost		i.kost.t,
					domain	tcmcs.str13	i.process.code,
					domain	tcmcs.str10	i.table)
{

#define	APPEND.IDTC(idtc)
^		APPEND.IDTC(o.sql.str, idtc)

#define	APPEND.IDTC(list, idtc)
^	if pos(list, idtc) <= 0 then
^		list = list & quoted.string(idtc) &","
^	endif

#define FILTER.KOOR(KOOR) (i.koor.f <= KOOR and KOOR <= i.koor.t)
#define FILTER.KOST(KOST) (i.kost.f <= KOST and KOST <= i.kost.t)

	|* ooieoey aiaaaeyao ia?aie?aeia ii oeiai aieoiaioia eioaa?aoee
	|* aey ?ac?uo i?ioannia
	domain	tcmcs.str256	o.sql.str
	o.sql.str = ""

	i.table = trim$(i.table)

	on case i.process.code
		case SELECT.GUID.LIST:
		case "twsap1206m100":
			o.sql.str = "%s.idtc in ("

			APPEND.IDTC(ZERO_PRICE_IDTC)
			
			if 	(FILTER.KOOR(tckoor.act.sfc) or
			     FILTER.KOOR(tckoor.act.asc))
			then
				if	FILTER.KOST(tckost.receipt) then
					APPEND.IDTC("10060052")
					APPEND.IDTC("10061074")
					APPEND.IDTC("10061117")
				endif
				if	FILTER.KOST(tckost.issue) then
					APPEND.IDTC("10060052")
					APPEND.IDTC("10061074")
					APPEND.IDTC("10061109")
				endif
			endif

			if 	FILTER.KOOR(tckoor.act.pur) then
				if	FILTER.KOST(tckost.receipt) then
					APPEND.IDTC("10060052")
					APPEND.IDTC("10061074")
					APPEND.IDTC("10061109")
					APPEND.IDTC("10061038")
					APPEND.IDTC("10060031")
					APPEND.IDTC("10001091")
				endif
				if	FILTER.KOST(tckost.issue) then
					APPEND.IDTC("10060052")
					APPEND.IDTC("10001051")
				endif
			endif

			if 	FILTER.KOOR(tckoor.act.sls) then
				if	FILTER.KOST(tckost.receipt) then
					APPEND.IDTC("15061074")
				endif
				|* SAL_ORD_...
				if	FILTER.KOST(tckost.issue) then
					APPEND.IDTC("10060052")
					APPEND.IDTC("10061074")
					APPEND.IDTC("15060052")
					APPEND.IDTC("10060116")
				endif
			endif

			if 	(FILTER.KOOR(tckoor.act.srv)) then
				if	FILTER.KOST(tckost.issue) then
					|* SER_MAT_Issue
					APPEND.IDTC("10060052")
					|* SER_MAT_Return
					APPEND.IDTC("10061074")
				endif
			endif

			if 	FILTER.KOOR(tckoor.act.trf) or
				FILTER.KOOR(tckoor.act.trf.man) or
				FILTER.KOOR(tckoor.enterprise.plan)
			then
				if	FILTER.KOST(tckost.receipt) then
					|* WH_Transfer
					APPEND.IDTC("10061074")
					APPEND.IDTC("10061088")
				endif
				if	FILTER.KOST(tckost.issue) then
					|* WH_Transfer_Low
					APPEND.IDTC("10060052")
				endif
			endif

			if 	FILTER.KOOR(tckoor.act.trf) or			|#SH-IPLCINT0010-1.n
				FILTER.KOOR(tckoor.act.trf.man) or
				FILTER.KOOR(tckoor.enterprise.plan)
			then
				|* PUR_Internal_Receipt
				if	FILTER.KOST(tckost.receipt) then
					APPEND.IDTC("10061086")
					APPEND.IDTC("10061087")
				endif
				|* SAL_Internal_Issue
				if	FILTER.KOST(tckost.issue) then
					APPEND.IDTC("10060054")
|					APPEND.IDTC("10060082")
					APPEND.IDTC("10060125")
|					APPEND.IDTC("10060087")
				endif
			endif

			if 	FILTER.KOOR(tckoor.act.sfc.man) or
				FILTER.KOOR(tckoor.act.dpt.wrk.man) or
				FILTER.KOOR(tckoor.act.asc.man)
			then
				if	FILTER.KOST(tckost.receipt) then
					APPEND.IDTC("10061074")
				endif
				if	FILTER.KOST(tckost.issue) then
					APPEND.IDTC("10060052")
				endif

			endif

			if 	FILTER.KOOR(tckoor.act.pur.man) then
				if	FILTER.KOST(tckost.receipt) then
					APPEND.IDTC("10060052")
					APPEND.IDTC("10060031")
					APPEND.IDTC("10061074")
					APPEND.IDTC("10061090")
				endif
			endif

			if 	FILTER.KOOR(tckoor.act.sls.man) then
				if	FILTER.KOST(tckost.issue) then
					APPEND.IDTC("10060052")
					APPEND.IDTC("10060031")
					APPEND.IDTC("10061074")
					APPEND.IDTC("10061090")
				endif
			endif

			|if 	FILTER.KOOR(tckoor.adjustment) then
				if	FILTER.KOST(tckost.stc.correction) then
					APPEND.IDTC("10054013")
					APPEND.IDTC("10055013")
				endif
			|endif

			o.sql.str = sprintf$(
				o.sql.str(1; len(o.sql.str) - 1) &")",
				i.table)

|			o.sql.str = o.sql.str & sprintf$(
|				" %s.idtc in ('10060052','10061074',"&
|				"'10001065','10001074','50050003'"&
|				(	i.koor = tckoor.act.sfc and
|					i.kost = tckost.receipt ?
|					"" : ",'10061109'") &
|				")",
|				i.table)

			break
		case RECONC.MASK:
			|* a iaai ee ia?aie?eaaou?
			| oa?ae yoio eaen
			|o.sql.str = "%s.idtc in ("
			|if 	FILTER.KOOR(tckoor.act.sls) then
			|	if	FILTER.KOST(tckost.issue) then
			|		APPEND.IDTC("10060116")
			|		APPEND.IDTC("10002052")
			|	endif
			|endif
			|if 	FILTER.KOOR(tckoor.act.sfc) then
			|	if	FILTER.KOST(tckost.receipt) then
			|		APPEND.IDTC("10060117")
			|		APPEND.IDTC("10014074")
			|	endif
			|endif
			|o.sql.str = sprintf$(
			|	o.sql.str(1; len(o.sql.str) - 1) &")",
			|	i.table)
			|on case 1
			|case PUR.RECEIPT:
			|	o.sql.str = o.sql.str & sprintf$(
			|		" %s.idtc in ('10001071','10001074','10001065') ",
			|		i.table)
			|	break
			|endcase
			
			o.sql.str = "%s.idtc in ("		
			if PUR.RECEIPT then
|					APPEND.IDTC("10001071")		|#SH-IPLCINT0014-1.o		
|					APPEND.IDTC("10001074")
|					APPEND.IDTC("10001065")		|#SH-IPLCINT0014-1.o
					APPEND.IDTC("10001091")
			else
				if 	g.inr.koor = tckoor.act.pur then
					if	g.inr.kost = tckost.issue then
						APPEND.IDTC("10001052")
					endif
					if	g.inr.kost = tckost.receipt then
						APPEND.IDTC("10001091")
					endif
				endif		
				if 	FILTER.KOOR(tckoor.act.trf.man) or
					FILTER.KOOR(tckoor.enterprise.plan)
				then
					if	FILTER.KOST(tckost.issue) then
						APPEND.IDTC("10060125")
					endif
				endif				
				if 	FILTER.KOOR(tckoor.act.sls) then
					if	FILTER.KOST(tckost.issue) then
						APPEND.IDTC("10060116")
						APPEND.IDTC("10002052")
					endif
				endif
				if 	FILTER.KOOR(tckoor.act.sfc) then
					if	FILTER.KOST(tckost.receipt) then
						APPEND.IDTC("10060117")
						APPEND.IDTC("10014074")
					endif
				endif
				if 	FILTER.KOOR(tckoor.act.dpt.wrk.man) then
					if	FILTER.KOST(tckost.issue) then
						APPEND.IDTC("10062052")
					endif
					if	FILTER.KOST(tckost.receipt) then
						APPEND.IDTC("10062074")
					endif
				endif
			endif
			o.sql.str = sprintf$(
				o.sql.str(1; len(o.sql.str) - 1) &")",
				i.table)
			break
		case RECONC.MASK.TRF:
			|* aey ia?aiauaiey aey ioaaoiie ?anoe aa?ai oieuei ioione
			|* oae eae ia?eiaai n iinooieaiey
			o.sql.str = o.sql.str & sprintf$(
					" %s.idtc = '10060052' ",
					i.table)
			break
		case "twsap1206m200":
			o.sql.str = o.sql.str & sprintf$(
				" %s.idtc = '10014061' " ,
				i.table)
			break
	endcase

	|* aiaaaeyai and a ia?aei oneiaey
	if i.mode and not isspace(o.sql.str) then
		o.sql.str = " and " & trim$(o.sql.str)
	endif

	return(o.sql.str)
}

|* koor_kost_3
function boolean must.be.found.reconciliation()
{
	if PUR.RECEIPT or
		WH.TRANSFER or
	   |TRF.RECEIPT or
	   |TRF.ISSUE.LOW or
	   WRITE.OFF or
	   (g.inr.koor = tckoor.act.pur or
	   g.inr.koor = tckoor.act.pur.man or
	   g.inr.koor = tckoor.act.sls.man) 
	then
		return(true)
	endif

	return(false)
}

|* koor_kost_4
function String get.koor.kost.statement(domain	tctbnm		i.tbnm,
					domain	tckoor		i.koor.f,
					domain	tckoor		i.koor.t,
					domain	tckost		i.kost.f,
					domain	tckost		i.kost.t)
{
	domain	tcmcs.str100	valid.koor, valid.kost, ret.list
		String		ret.stat(1024)

	valid.koor = concat$(DELIMITER,
		str$(etol(tckoor.act.sfc)),			|*  1
		str$(etol(tckoor.act.pur)),			|*	2
		str$(etol(tckoor.act.sls)),			|*  3
		str$(etol(tckoor.act.asc)),			|*  9
		str$(etol(tckoor.act.srv)),			|* 17

		str$(etol(tckoor.act.trf)),			|* 22
		str$(etol(tckoor.act.trf.man)),		|* 36
		str$(etol(tckoor.enterprise.plan)),	|* 60

		str$(etol(tckoor.act.sfc.man)),		|* 32
		str$(etol(tckoor.act.dpt.wrk.man)),	|* 42
		str$(etol(tckoor.act.asc.man)),		|* 46
		str$(etol(tckoor.act.pur.man)),		|* 33
		str$(etol(tckoor.act.sls.man)),		|* 34
		str$(etol(tckoor.cycle.count)), 	|* 51
		str$(etol(tckoor.adjustment))		|* 52
		)

	valid.kost = concat$(DELIMITER,
		str$(etol(tckost.stc.correction)),
		str$(etol(tckost.receipt)),
		str$(etol(tckost.issue)))

	ret.stat = get.valid.values(valid.koor, i.tbnm &".koor",
			etol(i.koor.f), etol(i.koor.t))
	ret.list = get.valid.values(valid.kost, i.tbnm &".kost",
			etol(i.kost.f), etol(i.kost.t))

	if not isspace(ret.list) then
		ret.stat = ret.stat & (isspace(ret.stat) ? "" : " and ")& ret.list
	endif

	return ( (isspace(ret.stat) ? "" : " and ")& ret.stat &" ")
}

function String get.valid.values(	domain	tcmcs.str100	i.list,
					domain	tcmcs.str20	i.fldn,
						long		i.valf,
						long		i.valt)
{
	String	ret.val(200)
	long	ret.cnt, posf, valu

	ret.val = ""
	ret.cnt = 0
	while not isspace(i.list)
		posf = pos(i.list, DELIMITER)
		if posf <= 0 then
			posf = len(i.list)
		endif
		valu = lval(i.list(1; posf))
		i.list = i.list(posf + 1)
		if valu >= i.valf and valu <= i.valt then
			ret.val = ret.val &","& str$(valu)
			ret.cnt = ret.cnt + 1
		endif
	endwhile
	if ret.cnt > 0 then
		ret.val = strip$(i.fldn) &" "&
			(ret.cnt > 1 ? "in (" : "= ") &
			ret.val(2) &		|* exclude leading comma
			(ret.cnt > 1 ? ")" : "")
	endif

	return (ret.val)
}

function extern domain tcncmp twsap.dll0116.get.fcmp.by.lcmp(
				domain tcncmp	i.lcmp)
{
		static	domain 	tcncmp		s.lcmp
		static 	domain	tcncmp		s.fcmp

		if s.lcmp = i.lcmp then
			return(s.fcmp)
		endif

		s.lcmp = i.lcmp
		s.fcmp = 0

		select 	tcemm030.fcmp:s.fcmp
		from	tcemm030
		where	tcemm030._compnr = {:i.lcmp}
		  and 	tcemm030.lcmp = :i.lcmp
		selectdo
		endselect

		if s.fcmp = 0 then
			s.fcmp = i.lcmp
		endif

		return(s.fcmp)
}

function domain	tcmcs.str30 get.gld106.key() {
	return (sprintf$("%d/%s/%d/%d/%d", tfgld106.ocmp, tfgld106.otyp,
			tfgld106.odoc, tfgld106.olin, tfgld106.osrl))
}


|*************************WH transfer mapping *****************************

function long create.transfer.order.mapping(
				domain	tcncmp		i.fcmp,
				domain	tcncmp		i.ref.fcom,
				domain	tcreco		i.ref.reco,
				domain	tcrecs		i.ref.recs,
				domain	tcguid		i.ref.link)
{
	| quan | amnt | amth |dbcr |  rbid | rpon | idtc | processed | proces_id
	| +30 +1 +30 +1 +30 +1 +1 +1  +11 +1  +4 +1 +8  +1 +1         + 32 = 151
#define	LEN.ARR	151
#define MASK.WRITE "%f~%f~%f~%1d~%11s~%8s~%f~%1d~%-32s"
#define MASK.READ  "%f~%f~%f~%d~%s~%s~%f~%d~%s"

#define	ADD.RECEIPT.ARR
^	receipt.count = receipt.count + 1
^	alloc.mem(receipt.arr,LEN.ARR,receipt.count)
^	receipt.arr(1,receipt.count) =
^			sprintf$(MASK.WRITE,
^				rec.amnt,rec.amth,rec.quan,
^				rec.dbcr,rec.rbid,rec.rpon,
^				rec.idtc,0,"")

#define	REAR.RECEIPT.ARR(NUM)
^	e = string.scan(receipt.arr(1,NUM),
^					MASK.READ,
^					rec.amnt,rec.amth,rec.quan,
^					rec.dbcr,rec.rbid,rec.rpon,
^					rec.idtc,rec.prcd,
^					dummy.str)

#define	ADD.ISSUE.ARR
^	issue.count = issue.count + 1
^	alloc.mem(issue.arr,LEN.ARR,issue.count)
^	issue.arr(1,issue.count) =
^			sprintf$(MASK.WRITE,
^				rec.amnt,rec.amth,rec.quan,
^				rec.dbcr,rec.rbid,rec.rpon,
^				rec.idtc,0,"")

#define	READ.ISSUE.ARR(NUM)
^	e = string.scan(issue.arr(1,NUM),
^				MASK.READ,
^				rec.i.amnt,rec.i.amth,rec.i.quan,
^				rec.i.dbcr,rec.i.rbid,rec.i.rpon,
^				rec.i.idtc,rec.i.prcd,
^				dummy.str)

#define LINES.PROCESSED(AMNT,AMTH,QUAN)
^	|* iiia?aai eae o?a ia?aaioaiiua no?iee (nnueea ia naycu)
^	rec.prcd = issue.i
^	rec.i.prcd = receipt.i
^	|* ii?aaaeyai oei i?iaiaee
^	rec.itpi = type.transfer(rec.idtc,rec.i.idtc)
^	|* ioia?aai iinooieaiea, eae ia?aaioaiiia
^	receipt.arr(1,receipt.i) =
^		sprintf$(MASK.WRITE,
^			AMNT,AMTH,QUAN,
^			rec.dbcr,rec.rbid,rec.rpon,
^			rec.idtc,rec.prcd,
^			rec.itpi)
^	|* caienuaaai i?iaiaeo ia noiio iinooieaiey
^	issue.arr(1,issue.i) =
^		sprintf$(MASK.WRITE,
^			AMNT,AMTH,QUAN,
^			rec.i.dbcr,rec.i.rbid,rec.i.rpon,
^			rec.i.idtc,rec.i.prcd,
^			rec.itpi)


	|domain	tcncmp		rec.fcom
	|domain	tcreco		rec.reco
	|domain	tcrecs		rec.recs
	|domain	tcguid		rec.link

	domain	tfgld.dbcr 	rec.dbcr
	domain	tcboid		rec.rbid
	domain	tcpono		rec.rpon
	domain	tcidty		rec.idtc
	domain	tfgld.amnt	rec.amnt
	domain	tfgld.amnt	rec.amth
	domain	tcqiv1		rec.quan
	domain	tcqiv1		rec.prcd 	|0-ia ia?aaioaii, <>0 -(nnueea ia naycu)

	domain	tfgld.dbcr 	rec.i.dbcr
	domain	tcboid		rec.i.rbid
	domain	tcpono		rec.i.rpon
	domain	tcidty		rec.i.idtc
	domain	tfgld.amnt	rec.i.amnt
	domain	tfgld.amnt	rec.i.amth
	domain	tcqiv1		rec.i.quan
	domain	tcqiv1		rec.i.prcd |0-ia ia?aaioaii, <>0 -(nnueea ia naycu)

	domain	tcmcs.long	rec.sap108.num

	domain	tcmcs.str32	rec.itpi

	domain	tcmcs.str32 dummy.str

	string	receipt.arr(1,1)	based
	long	receipt.count
	long	receipt.i

	string	issue.arr(1,1)	based
	long	issue.count
	long	issue.i


	long	link.found

	free.mem(receipt.arr)
	free.mem(issue.arr)
	receipt.count = 0
	issue.count = 0
	rec.sap108.num = 0

	rec.sap108.num = transfer.order.mapping.for.rbid.exist(g.int.rbid)
	if rec.sap108.num <> 0 then
		|* ei??aniiiaaioey o?a anou, no?ieou aa caiiai ia io?ii
		return(rec.sap108.num)
	endif

	|rec.link = ""
	|select	t1.fcom:rec.fcom,
	|		t1.reco:rec.reco,
	|		t1.recs:rec.recs,
	|		t1.link:rec.link
	|from	tfgld482 t0,
	|		tfgld495 t1
	|where	t0._index2 = {	:tfgld106.ocmp, :g.int.rbon,
	|			:g.int.rbid, :g.int.rpon}
	|  and	t0.trdt = :tfgld482.trdt|* tfgld482.trdt
	|  and	t0._compnr = :i.fcmp
	|  and	t1._index1 = {t0.guid, t0.dbcr}
	|  and	t1.link <> ""
	|  and	t1._compnr = :i.fcmp
	|group by t1.fcom, t1.reco, t1.recs, t1.link
	|selectdo
	|endselect
	|
	|if isspace(rec.link) then
	|	return(false)
	|endif

	select	t1.nuni:rec.quan,
			t1.dbcr:rec.dbcr,
			t1.amnt:rec.amnt,
			t1.amth(1):rec.amth	,
			t1.rbid:rec.rbid,
			t1.rpon:rec.rpon,
			t1.idtc:rec.idtc
	from	tfgld495 t1
	where	t1._index9 = {:i.ref.fcom, :i.ref.reco, :i.ref.recs, :i.ref.link}
	and		t1._compnr 	= :i.fcmp
	|and		t1._compnr = :g.int.lcmp
	group by t1.nuni,t1.dbcr,t1.amnt,t1.amth,t1.rbid,t1.rpon,t1.idtc
	order by t1.nuni desc ,t1.dbcr,t1.amnt,4,t1.rbid,t1.rpon,t1.idtc
	selectdo
		if not transfer.order.mapping.for.rbid.exist(rec.rbid) then
			on case rec.idtc
			case "10061088": |* Nee. iinooieaiea/Ioeeiiaiea ii ioa?ocea
				|* ?acaa?a?eaaai ioeeiiaiea ioionea a iinooieaiea n +
				rec.amnt = abs(rec.amnt)
				rec.amth = abs(rec.amth)
			case "10061074" : |* Nee. iinooieaiea/iinooieaiea
			case "10062052" : |* Cee. caeac/ioione
					ADD.RECEIPT.ARR
				break
			case "10060088": |* Nee. ioione/Ioeeiiaiea ii ioa?ocea
				|* ?acaa?a?eaaai ioeeiiaiea  iinooieaiey a ioione n +
				rec.amnt = abs(rec.amnt)
				rec.amth = abs(rec.amth)
			case "10060052": |* Nee. ioione/ioione
					ADD.ISSUE.ARR
				break
			endcase
		endif
	endselect

	|* ia?eiaai eneaou i?iaiaee, aa?ai aIeuoo? noiio iinooieaiey,
	|* e euai iiaoiayuo? noiio ioionea.

	long count.cycle
	count.cycle = 0
	repeat
		link.found = false
		count.cycle = count.cycle+1
		|mess("twsap.empty",0,
		|	sprintf$("count.cycle,rec=%d",0,count.cycle))
		for receipt.i = 1 to receipt.count
			REAR.RECEIPT.ARR(receipt.i)
			if rec.prcd <> 0 then
				|* iinooieaiea ia?aaioaii, aa?ai neaao?uo? no?ieo iinooieaiey
				continue
			endif

			|* euai ei??aniiiae?o?uo? no?ieo ioione
			for issue.i = 1 to issue.count
				READ.ISSUE.ARR(issue.i)
				|* aa?ai oieuei iaia?aaioaiiua caiene
				if rec.i.prcd <> 0 then
					continue
				endif
				link.found = true
				on case 1
				|* ia?aui i?ioiaii noeiiuaaai oieuei iaeiaeiaua eiee?anoaa
				case (EQUAL.TO(rec.quan,rec.i.quan)=true):

						LINES.PROCESSED(rec.amnt,rec.amth,rec.quan)

						|* caienuaaai i?iaiaeo a oaaeeoo i?iaiaie twsap108
						write.to.twsap108(
								rec.amnt,rec.amth,rec.quan,
								rec.dbcr,rec.rbid,rec.rpon,
								rec.idtc,
								rec.i.dbcr,rec.i.rbid,rec.i.rpon,
								rec.i.idtc,
								rec.itpi,
								rec.sap108.num)

						break
				|* anee iinooieaiea iaiuoa ioionea
				case (LESS.THAN(rec.quan,rec.i.quan)=true):

						LINES.PROCESSED(rec.amnt,rec.amth,rec.quan)

						|* caienuaaai i?iaiaeo a oaaeeoo i?iaiaie twsap108
						write.to.twsap108(
								rec.amnt,rec.amth,rec.quan,
								rec.dbcr,rec.rbid,rec.rpon,
								rec.idtc,
								rec.i.dbcr,rec.i.rbid,rec.i.rpon,
								rec.i.idtc,
								rec.itpi,
								rec.sap108.num)

						|* caienuaaai iiao? no?ieo ioionea ia ?acieoo
						|* ioione - iinooieaiea a iannea ioionea.
						issue.count = issue.count + 1
						alloc.mem(issue.arr,LEN.ARR,issue.count)
						issue.arr(1,issue.count) =
							sprintf$(MASK.WRITE,
								(rec.i.amnt - rec.amnt),
								(rec.i.amth - rec.amth),
								(rec.i.quan - rec.quan),
								rec.i.dbcr,rec.i.rbid,rec.i.rpon,
								rec.i.idtc,0,
								"")
						break
				|* anee iinooieaiea aieuoa ioionea
				case (GREATER.THAN(rec.quan,rec.i.quan)=true):

						LINES.PROCESSED(rec.i.amnt,rec.i.amth,rec.i.quan)

						|* caienuaaai i?iaiaeo a oaaeeoo i?iaiaie twsap108
						write.to.twsap108(
								rec.i.amnt,rec.i.amth,rec.i.quan,
								rec.dbcr,rec.rbid,rec.rpon,
								rec.idtc,
								rec.i.dbcr,rec.i.rbid,rec.i.rpon,
								rec.i.idtc,
								rec.itpi,
								rec.sap108.num)

						|* caienuaaai iiao? no?ieo iinooieaiey ia ?acieoo
						|* iinooieaiea - ioione a iannea ioionea.
						receipt.count = receipt.count + 1
						alloc.mem(receipt.arr,LEN.ARR,receipt.count)
						receipt.arr(1,receipt.count) =
							sprintf$(MASK.WRITE,
								(rec.amnt - rec.i.amnt),
								(rec.amth - rec.i.amth),
								(rec.quan - rec.i.quan),
								rec.dbcr,rec.rbid,rec.rpon,
								rec.idtc,0,
								"")
						break
				endcase
				if rec.i.prcd <> 0 then
					|* anee iaoee ei??aniiiaaioe?, oi auoiaei ec oeeea issue.i
					break
				endif
			endfor
		endfor
	until not link.found

	free.mem(receipt.arr)
	free.mem(issue.arr)
	receipt.count = 0
	issue.count = 0

	return(rec.sap108.num)
}

function long transfer.order.mapping.for.rbid.exist(
					domain	tcboid	i.rbid)
{
	long	o.max.seqn

	o.max.seqn = 0
	select 	max(twsap108.seqn):o.max.seqn
	from	twsap108
	where	twsap108._index1 = {:g.inr.koor,:g.int.orno,:g.int.pono}
	  and 	twsap108.rbid = :i.rbid
	selectdo
	endselect
	return(o.max.seqn)
}

function domain tcmcs.str32 type.transfer(
					domain	tcidty i.receipt.idtc,
					domain	tcidty i.issue.idtc)
{
	domain	tcmcs.str32 o.rec.itpi

	o.rec.itpi = ""

	on case 1
	case (i.receipt.idtc = "10061074" and i.issue.idtc = "10060052"):
		o.rec.itpi = "WH_Transfer"
		break
	case (i.receipt.idtc = "10061074" and i.issue.idtc = "10060088"):
	case (i.receipt.idtc = "10061088" and i.issue.idtc = "10060052"):
		o.rec.itpi = "WH_Transfer_Deviations"
		break
	case (i.receipt.idtc = "10062052" and i.issue.idtc = "10060052"):
		o.rec.itpi = "WH_Transfer_Low"
		break
	endcase

	return(o.rec.itpi)
}

function write.to.twsap108(
				domain	tfgld.amnt	i.amnt,
				domain	tfgld.amnt	i.amth,
				domain	tcqiv1		i.quan,
				domain	tfgld.dbcr	i.dbcr,
				domain	tcboid		i.rbid,
				domain	tcpono		i.rpon,
				domain	tcidty		i.idtc,
				domain	tfgld.dbcr	i.dbcr.cor,
				domain	tcboid		i.rbid.cor,
				domain	tcpono		i.rpon.cor,
				domain	tcidty		i.idtc.cor,
				domain	tcmcs.str32	i.itpi,
			ref	domain	tcmcs.long	i.seqn)
{

	domain tcpono	dummy.pono

	select 	twsap108.pono:dummy.pono
	from	twsap108
	where	twsap108._index1 = {:g.inr.koor,:g.int.orno,:g.int.pono}
	  and 	twsap108.idtc = :i.idtc
	  and 	twsap108.rbid = :i.rbid
	  and	twsap108.rpon = :i.rpon
	  and 	twsap108.idtc.cor = :i.idtc.cor
	  and 	twsap108.rbid.cor = :i.rbid.cor
	  and	twsap108.rpon.cor = :i.rpon.cor
	as set with 1 rows
	selectdo
		|* anee i?iaiaea o?a anou, oi iiao? ia aiaaaeyai
		return
	endselect

	db.set.to.default(ttwsap108)
	twsap108.koor 	= g.inr.koor
	twsap108.orno	= g.int.orno
	twsap108.pono	= g.int.pono
	|twsap108.seqn	= 0
	twsap108.rbid	= i.rbid
	twsap108.rpon   = i.rpon
	twsap108.idtc	= i.idtc
	twsap108.dbcr	= i.dbcr
	twsap108.quan	= i.quan
	twsap108.amnt	= i.amnt
	twsap108.amth	= i.amth
	twsap108.rbid.cor	= i.rbid.cor
	twsap108.rpon.cor   = i.rpon.cor
	twsap108.idtc.cor	= i.idtc.cor
	twsap108.dbcr.cor	= i.dbcr.cor

	twsap108.itpi	= i.itpi		|type.transfer(i.idtc,i.idtc.cor)
	|twsap108.prcd	= tcyesno.no

	repeat
		i.seqn	= i.seqn + 1
		twsap108.seqn	= i.seqn
		e = db.insert(ttwsap108,db.retry,DB.RETURN.DUPL)
	until (e=0)

}

|************************ print tech report ************************************

function extern twsap.dll0116.print.tech.report(
				ref String	i.pr.line)
{
	long	i

	if tech.report = tcyesno.yes then
		if not tech.report.id then
			|* open empty reports
			tech.report.id = spool.open("", "NOTEPAD", 0)
		endif

		|* fill report line
		if len(i.pr.line) > 1000 then
			spool.pr.line = i.pr.line(1;1000)
			spool.line()

			spool.pr.line = i.pr.line(1001)
			spool.line()
		else
			spool.pr.line = i.pr.line
			|* print report line
			spool.line()
		endif

		for i = 1 to 2
			|* add empty lines
			spool.pr.line = ""
			|* print report line
			spool.line()
		endfor
	endif
}

function extern twsap.dll0116.close.tech.report()
{
	if tech.report.id then
		spool.close()
		tech.report.id = 0
	endif
}


function show.progress.indicator(
				long	i.pr.bar,
				string i.text(100),
				long	i.recn)
{
		long 	ret
		domain	tcdate		proc.time
		long 	percent
		domain	tfgld.amnt	speed.rec
		string	pack.text(100)
		string	time.text(100)
		string	speed.text(100)

		if job.process then
			mess("twsap.empty",0,i.text)
		else
			if prog.ind = 0 then
				if i.pr.bar then
					ret = create.progress.indicator(
							sattr.descr$,
	                    	PROGRESS.BAR + PROGRESS.NOAUTODESTROY)
	                if ret = 0 then
	                	prog.ind = 1
	                endif
	           	else
	        		prog.ind = create.progress.indicator(
							sattr.descr$)
	        	endif
|	                    ret = change.progress.indicator( 0, prog.name$ )
	        endif

			if g.max.pack.guid <> 0 then
				percent =  (g.cur.pack * 100) / g.max.pack.guid
				pack.text = ""
				if g.cur.pack <= g.max.pack.guid  then
					pack.text = " Package: " & concat$("/",g.cur.pack,g.max.pack.guid)
				endif
				pack.text = trim$(g.process.name) & " " & trim$(pack.text)
			else
				percent = 1
				pack.text = trim$(g.process.name)
			endif

			|* timer
			finish.time = utc.num()
			proc.time = (finish.time - start.time)

			speed.text = ""
			if 	i.recn <> 0 and proc.time <> 0 then
				speed.rec = (i.recn)/proc.time
				speed.text = sprintf$("speed= %d rec/sec; ",speed.rec)
			endif

			time.text =
			sprintf$(
					"time= %02d:%02d:%02d; " &
					"'%u002 %U(%02H:%02m:%02s)' -> " &
					"'%u002 %U(%02H:%02m:%02s)' ",
					proc.time/3600,
					(proc.time\3600)/60,
					(proc.time\3600\60),
					start.time,start.time,
					finish.time,finish.time)

	        ret = change.progress.indicator(
	        			percent,
	        			"Company: " & str$(get.compnr()),
						trim$(pack.text),
						trim$(i.text),
						trim$(time.text),
						trim$(speed.text))

	        if ret <> 0 then

	        endif
	    endif
}

function close.progress.indicator()
{
		if prog.ind <> 0 then
            destroy.progress.indicator()
      	endif
      	g.process.name = ""
		prog.ind = 0

}


function extern long read.parallel.pack.num(
				ref	domain	tcguid		o.guid.list,
				ref domain	tcmcs.long	o.pack.from,
				ref	domain	tcmcs.long	o.pack.to)
{
	domain	tcmcs.st20m	dummy.upid
   	domain	tcmcs.str10	dummy.target
   	domain	tcncmp		dummy.fcmp
   	domain	tcncmp		dummy.lcmp
   	domain	tcyesno		dummy.simm
	e = string.scan(
				"%s~%s~%d~%d~%d~%s~%d~%d",
				twsap.dll0116.parallel.serv.mess,
				dummy.upid,
				dummy.target,
				dummy.fcmp,
				dummy.lcmp,
				dummy.simm,
				o.guid.list,
				o.pack.from,
				o.pack.to)
				
	if e <> 8 then 
		|* oeaiy eaeay-oi i?iecioea
		return(false)
	endif
	
	return(true)
}

function extern long twsap.dll0116.read.parallel.mode(
					domain	tcmcs.s256	i.serv.mess,
				ref domain	tcmcs.str20	o.mode
				)
{
	
	domain	tcmcs.st20m	tmp.upid
   	domain	tcmcs.str10	tmp.target
   	domain	tcncmp		tmp.fcmp
   	domain	tcncmp		tmp.lcmp
   	domain	tcyesno		tmp.simm
	domain	tcguid		tmp.guid.list
	domain	tcmcs.long	tmp.pack.from
	domain	tcmcs.long	tmp.pack.to
	domain	tcmcs.s140	tmp.add.text
	domain	tckoor		tmp.koor.f
	domain	tckoor		tmp.koor.t
	domain	tckost		tmp.kost.f
	domain	tckost		tmp.kost.t				
	
	return(twsap.dll0116.read.parallel.message(
				i.serv.mess,
				o.mode,
				tmp.upid,
   				tmp.target,
   				tmp.fcmp,
   				tmp.lcmp,
   				tmp.simm,
				tmp.guid.list,
				tmp.pack.from,
				tmp.pack.to,
				tmp.koor.f,
				tmp.koor.t,
				tmp.kost.f,
				tmp.kost.t,				
				tmp.add.text))

}

function extern long twsap.dll0116.read.parallel.message(
					domain	tcmcs.s256	i.serv.mess,
				ref domain	tcmcs.str20	o.mode,
				ref	domain	tcmcs.st20m	o.upid,
   				ref	domain	tcmcs.str10	o.target,
   				ref	domain	tcncmp		o.fcmp,
   				ref	domain	tcncmp		o.lcmp,
   				ref	domain	tcyesno		o.simm,
				ref	domain	tcguid		o.guid.list,
				ref domain	tcmcs.long	o.pack.from,
				ref	domain	tcmcs.long	o.pack.to,
				ref domain	tckoor		o.koor.f,
				ref domain	tckoor		o.koor.t,
				ref domain	tckost		o.kost.f,
				ref domain	tckost		o.kost.t,				
				ref	domain	tcmcs.s140	o.add.text)
{
	e = string.scan(
				i.serv.mess,
				"%s~%s~%s~%d~%d~%d~%s~%d~%d~%d~%d~%d~%d~%s",
				o.mode,
				o.upid,
				o.target,
				o.fcmp,
				o.lcmp,
				o.simm,
				o.guid.list,
				o.pack.from,
				o.pack.to,
				o.koor.f,
				o.koor.t,
				o.kost.f,
				o.kost.t,
				o.add.text)
				
	if e <> 14 then 
		|* oeaiy eaeay-oi i?iecioea
		return(false)
	endif
	
	return(true)
}

function extern domain tcmcs.s256 twsap.dll0116.create.parallel.message(
				domain	tcmcs.str20	i.mode,
				domain	tcmcs.st20m	i.upid,
   				domain	tcmcs.str10	i.target,
   				domain	tcncmp		i.fcmp,
   				domain	tcncmp		i.lcmp,
				domain	tcyesno		i.simm,
				domain	tcguid		i.guid.list,
				domain	tcmcs.long	i.pack.from,
				domain	tcmcs.long	i.pack.to,
				domain	tckoor		i.koor.f,
				domain	tckoor		i.koor.t,
				domain	tckost		i.kost.f,
				domain	tckost		i.kost.t,
				domain	tcmcs.s140	i.add.text)
{
	domain tcmcs.s256 o.mess
	
	o.mess = concat$("~",
				i.mode,
				i.upid,
				i.target,
				i.fcmp,
				i.lcmp,
				i.simm,
				i.guid.list,
				i.pack.from,
				i.pack.to,
				i.koor.f,
				i.koor.t,
				i.kost.f,
				i.kost.t,
				trim$(i.add.text))
	
	return(o.mess)
}

function extern long twsap.dll0116.read.total.rec.in.pack(
				domain	tcguid		i.guid.list,
				domain	tcmcs.long	i.pack.from,
				domain	tcmcs.long	i.pack.to)
{
	long o.total.rec
	
	o.total.rec = 0 
	
	select 	count(*):o.total.rec
	from	twsap110 
	where	twsap110._index1 inrange {:i.guid.list,:i.pack.from}
								 and {:i.guid.list,:i.pack.to}
	selectdo
	endselect
	
	return(o.total.rec)
	
}

function long run.parallel.process(
				domain	tcmcs.str20	i.mode,
				domain	tcmcs.st20m	i.upid,
   				domain	tcmcs.str10	i.target,
   				domain	tcncmp		i.fcmp,
   				domain	tcncmp		i.lcmp,
				domain	tcyesno		i.simm,
				domain	tcguid		i.guid.list,
				domain	tcmcs.long	i.pack.from,
				domain	tcmcs.long	i.pack.to,
				domain	tckoor		i.koor.f,
				domain	tckoor		i.koor.t,
				domain	tckost		i.kost.f,
				domain	tckost		i.kost.t,
			ref	domain	tcmcs.long	o.recs)
{
	long	group.id
	long 	nr.of.server
	
	domain	tcmcs.s100	mess.text
	domain	tcmcs.s100	serv.mess
			string		add.text(1)
			
			long		serv.ret
	domain	tcmcs.long	serv.guids
	domain	tcmcs.long	serv.recs
	domain	tcncmp		save.comp
			
			long	i 
	

#define SERVER.SESS "twsap1206m100"
	|* Read Configuration
	|* only from company 201
	save.comp = 0
	if get.compnr() <> 201 then 
		save.comp = get.compnr()
		e = switch.to.company(201)
	endif
	
    nr.of.server = par.get.no.of.server()
    if nr.of.server > 0 then
        |* Start communication
        group.id = par.init.client.to.server(nr.of.server, SERVER.SESS)
        |* Start the servers 
        if group.id < 1 or
           not par.client.start.servers(group.id) then
            return(-2)
        endif
    endif
    
    if save.comp <> 0 then
    	 e = switch.to.company(save.comp)
    endif

	|o.recs = 0 
	|dll.count.guids = 0 
	if nr.of.server > 0 then
		for i = i.pack.from to i.pack.to 
			if dll0116.use.hint = tcyesno.yes then 
				add.text = "1"
			else 
				add.text = "2"
			endif
			mess.text = twsap.dll0116.create.parallel.message(
					i.mode,
					i.upid,
	   				i.target,
	   				i.fcmp,
	   				i.lcmp,
					i.simm,
					i.guid.list,
					i,
					i,
					i.koor.f,
					i.koor.t,
					i.kost.f,
					i.kost.t,
					add.text)	|* ia?aaaai dll0116.use.hint
					|"")
					
			par.client.send.message(group.id, mess.text)
		endfor
	
    	|* Wait until all servers are ready
    	par.client.wait.ready(group.id)
    	
    	|* read return message
    	while par.client.get.message  (group.id,serv.mess) > 0 
    			e = string.scan(
    						serv.mess,
    						"%d~%d~%d",
    						serv.ret,
    						serv.guids,
    						serv.recs)
    			if serv.ret and serv.recs > 0 then
    				o.recs = o.recs + serv.recs
    				dll.count.guids = dll.count.guids + serv.guids
    			|else 
    			|	message("@ error parallel server message")
    			endif
    	endwhile

		
        |* Close the communication and stop the servers
        par.client.close.servers(group.id)
    
	    if not isspace(g.guid.list) then
				show.progress.indicator(1,"Clear package list table ",o.recs)
				clear.guid.list(i.guid.list)
		endif
		close.progress.indicator()
	endif
	
	return(nr.of.server)
}
